{"posts":[{"title":"Hobbits(傻逼计算几何题)","content":"做法：倒着扫一遍维护最高点(最高点不一定是高度最高的点，是覆盖面积最大的点)，然后判断于直线的交点即可 #include &lt;bits/stdc++.h&gt; #define x first #define y second using namespace std; const double eps = 1e-8; typedef pair&lt;double, double&gt; pdd; const int N=2e5+10; double operator*(pdd a, pdd b) { return a.x * b.y - a.y * b.x; } pdd operator-(pdd a,pdd b) { return {a.x-b.x,a.y-b.y}; } struct line { pdd st, ed; }li[N]; pdd poi[N]; int n; double h; int dcmp(double a, double b) { if (fabs(a - b) &lt;= eps) return 0; if (a &lt; b) return -1; return 1; } double getdis(pdd a,pdd b) { double dx=a.x-b.x,dy=a.y-b.y; return sqrt(dx*dx+dy*dy); } double cross(pdd a,pdd b) { return a*b; } pdd get_line_intersection(pdd p, pdd v, pdd q, pdd w) { auto u = p - q; double t = cross(w, u) / cross(v, w); return {p.x + v.x * t, p.y + v.y * t}; } pdd get_line_intersection(line a, line b) { return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st); } int main() { cin&gt;&gt;n&gt;&gt;h; for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;poi[i].x,&amp;poi[i].y); pdd mx=poi[n],eye={poi[n].x,poi[n].y+h}; double ans=0; for(int i=n-1;i&gt;=1;i--) { auto p1=mx-eye,p2=poi[i]-eye,p3=poi[i+1]-eye; int f1=dcmp(p1*p2,0),f2=dcmp(p1*p3,0); //cout&lt;&lt;f1&lt;&lt;&quot; &quot;&lt;&lt;f2&lt;&lt;&quot;\\n&quot;; if(f1&lt;=0&amp;&amp;f2&lt;=0) ans+=getdis(poi[i],poi[i+1]); else if(f1&lt;=0&amp;&amp;f2&gt;0) { pdd pp=get_line_intersection(line{eye,mx},line{poi[i],poi[i+1]}); ans+=getdis(pp,poi[i]); } if(f1&lt;=0) mx=poi[i]; } printf(&quot;%.6lf&quot;,ans); return 0; } ","link":"https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/"},{"title":"容斥原理","content":"容斥原理：∣\\mid∣ S-A⋃\\bigcup⋃B∣\\mid∣ =S-A-B+A⋂\\bigcap⋂B ","link":"https://Bsgg1.github.io/post/rong-chi-yuan-li/"},{"title":"cf round766 div2（四题待更）","content":"A： 首先考虑不可能的情况就是全部都是白色，如果有一个黑色就可以操作一行一列所以一定有解 如果r，c是黑ans为0 r，c所在的列或者行有一个黑就是1 否则就是2 #include &lt;bits/stdc++.h&gt; #define x first #define y second #define LOCAL #define int long long using namespace std; const int N = 550; using pii = pair&lt;int, int&gt;; pii que[N]; char f[N][N]; int t, n, k,m; signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m; int r,c;cin&gt;&gt;c&gt;&gt;r; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;f[i][j]; int k1=0,k2=0; int k3=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(f[i][j]=='B') k3++; for(int i=1;i&lt;=m;i++) if(f[c][i]=='B') k1++; for(int i=1;i&lt;=n;i++) if(f[i][r]=='B') k2++; //cout&lt;&lt;k1&lt;&lt;&quot; &quot;&lt;&lt;k2&lt;&lt;&quot;\\n&quot;; if(k3==0) puts(&quot;-1&quot;); else { if(f[c][r]=='B') puts(&quot;0&quot;); else if(k1||k2) puts(&quot;1&quot;); else puts(&quot;2&quot;); } } return 0; } B:舔狗的故事 做法：首先是舔狗先选位置，女神会坐在距离他最远的地方，所以求出每个位置的距离，排个序输出就好了 #include &lt;bits/stdc++.h&gt; #define x first #define y second #define LOCAL using namespace std; const int N = 550; using pii = pair&lt;int, int&gt;; pii que[N]; int t, n, k,m; vector&lt;int&gt; e; signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m; e.clear(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { e.push_back(max(max(i-1+j-1,abs(i-n)+j-1),max(abs(i-n)+abs(j-m),i-1+abs(j-m)))); } sort(e.begin(),e.end()); for(auto x:e) cout&lt;&lt;x&lt;&lt;&quot; &quot;; puts(&quot;&quot;); } return 0; } c: 素数除去2剩下的都是奇数，若想相邻两条边加起来还是素数，那么最终的形式只能是一条链，然后边权23交替就好 #include&lt;bits/stdc++.h&gt; #define LOCAL #define x first #define y second using namespace std; int t; int n; typedef pair&lt;int,int&gt; pii; const int N=1e5+10; int h[N],e[2*N],ne[2*N],idx; pii q[N]; int c[N]; map&lt;pii,int&gt; mp; int res; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void dfs(int u,int fa) { for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j==fa) continue; mp[{u,j}]=mp[{j,u}]=res; res=5-res; dfs(j,u); } } int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); #endif cin&gt;&gt;t; while(t--) { idx=0; mp.clear(); memset(h,-1,sizeof h); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) c[i]=0; bool fl=true; for(int i=1;i&lt;n;i++) { int x,y;cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); q[i]={x,y}; c[x]++,c[y]++; } int l; for(int i=1;i&lt;=n;i++) { if(c[i]&gt;2) { fl=false; break; } if(c[i]==1) l=i; } //cout&lt;&lt;l&lt;&lt;&quot;\\n&quot;; res=2; if(!fl) puts(&quot;-1&quot;); else { dfs(l,-1); for(int i=1;i&lt;n;i++) cout&lt;&lt;mp[q[i]]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); } } return 0; } d: 由于gcd(a,b)小于等于ab的最小值，所以我们可以考虑对于一个数x若未出现在序列中，如果存在在序列中的大于x的倍数的gcd是x，那么通过一系列gcd操作就可以得到这个数 #include &lt;bits/stdc++.h&gt; #define LOCAL #define x first #define y second using namespace std; int t; int n; typedef pair&lt;int, int&gt; pii; const int N = 1e6 + 10; bool st[N]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; st[x] = true; } int ans = 0; for (int i = 5e5; i; i--) { if (!st[i]) { int k = 0; for (int j = i; j &lt;= 1e6; j += i) if (st[j]) k = __gcd(k, j); if (k == i) ans++; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0; } ","link":"https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/"},{"title":"CF round 756 div2（未完待更）","content":"A: 考虑对于二进制的某一位，如果1的数量大于0的数量那么这一位就需要是1 #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; int c1[50], c2[50]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) c1[i] = c2[i] = 0; while (n--) { int x; cin &gt;&gt; x; for (int i = 0; i &lt; k; i++) { if (x % 2 == 1) c1[i]++; else c2[i]++; x /= 2; } } int a = 1, res = 0; for (int i = 0; i &lt; k; i++) { if (c1[i] &gt; c2[i]) res = res + a; a = a * 2; } cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; } return 0; } B: 很容易想到体中所说的匹配指的是存在两个一样的k，他们前边有a个数，后边有b个数，让a+b+1最大 然后我们发现长度就是n-dis(k1,k2) #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; const int N=2e5+10; vector&lt;int&gt; e[N]; int a[N]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int t; cin &gt;&gt; t; while (t--) { for(int i=1;i&lt;=150000;i++) e[i].clear(); int n, k; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) { int x;cin&gt;&gt;x; e[x].push_back(i); } int res=-1; for(int i=1;i&lt;=150000;i++) { if(e[i].size()&gt;=2) { k=0x3f3f3f3f; for(int j=1;j&lt;e[i].size();j++) { k=min(k,e[i][j]-e[i][j-1]); } res=max(res,n-k); } } cout&lt;&lt;res&lt;&lt;&quot;\\n&quot;; } return 0; } C：考虑第i个位置是从第j个位置转移来的，n3dp #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 550; int a[N], d[N], dp[N][N]; int n, l, k; int main() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; a[n + 1] = l; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; d[i]; d[n + 1] = 0; n++; memset(dp, 0x3f, sizeof dp); dp[1][0] = 0; for (int i = 2; i &lt;= n; i++){ for (int j = 0; j &lt;= k; j++){ dp[i][j] = dp[i - 1][j] + (a[i] - a[i - 1]) * d[i - 1]; for(int s=1;s&lt;i;s++) { if(j-(i-s-1)&lt;0) continue; dp[i][j]=min(dp[i][j],dp[s][j-(i-s-1)]+(a[i]-a[s])*d[s]); } } } int res=0x3f3f3f3f; for(int i=0;i&lt;=k;i++) res=min(res,dp[n][i]); cout&lt;&lt;res&lt;&lt;&quot;\\n&quot;; return 0; } ","link":"https://Bsgg1.github.io/post/cf-round-756/"},{"title":"积性函数，莫比乌斯反演(未完待更)","content":"积性函数的定义：如果对于一个函数F : N - R,对于任意互质的a与b都有F(ab)=F(a)f(b),则称F为积性函数 如果F与G都是积性函数，那么H(i)=F(i)G(i) 也是积性函数 如何求解积性函数？ n=p1q1 ×\\times× p2q2 ×\\times× p3q3 ⋯\\cdots⋯ ×\\times× pnqn 所以F(n)=F(p1q1) ×\\times× F(p2q2) ⋯\\cdots⋯ ×\\times× F(pnqn) 利用欧拉筛求F(1-n) f[1]=1; for(int i=2;i&lt;=n;i++) { if(!st[i]) prime[++cnt]=i;f[i]=cal_f(i,1); for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++) { st[i*prime[j]]=true; if(i%j==0) { cnt[i*prime[j]]=cnt[i]+1; f[i*prime[j]]=f[i]/cal_f(p[j],cnt[i])*cal_f(p[j],cnt[i*f[j]]); break; } cnt[i*f[j]]=1; f[i*prime[j]]=f[i]*cal_f(f[j],1); } } 练习 1.简单应用： 求 1n ⨁\\bigoplus⨁ 2n ⨁\\bigoplus⨁ ⋯\\cdots⋯ nn 定义函数F，F(i)=in,所以F是一个积性函数，可以预处理出来1-n的F值，然后进行求解 #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; #define int long long const int N = 1e6 + 10; const int mod = 1e9 + 7; int f[N * 13], prime[N]; bool st[N * 13]; int c[N]; int cnt; int n; int qpw(int a, int b) { int res = 1; while (b) { if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } void init() { for (int i = 2; i &lt;= n; i++) { if (!st[i]) prime[++cnt] = i, f[i] = qpw(i, n); for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) { st[prime[j] * i] = true; f[i * prime[j]] = f[i] * f[prime[j]] % mod; if (i % prime[j] == 0) break; } } } signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif f[1] = 1; cin &gt;&gt; n; init(); int res = 0; for (int i = 1; i &lt;= n; i++) res = (res ^ f[i]); cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; return 0; } 结论：F是一个积性函数的话，G=∑\\sum∑d∣\\mid∣nF(d)也是积性函数 题目：cf 757-E 题意：定义函数F0(n)=u*v==n&amp;&amp;gcd(u,v)==1的个数 很显然我们可以发现F0(n)=2k,k是n分解后的项数，所以F0是一个积性函数 Fr(n)=∑\\sum∑d∣\\mid∣n Fr-1(d) 根据推论所以Fr也是一个积性函数 对于Fr(n)=Fr(p1q1)⨁\\bigoplus⨁Fr(p2q2)⋯\\cdots⋯ Fr(pnqn) 然后可以发现对于形如Fr(p1q1)的求解是通过递归求得的，并且与p1无关，q最大是20，所以可以先预处理，然后进行求解 这个题在处理素数时可以只处理1000以内的素数，一个数最多有一个质因子是大于根号的 代码： #include &lt;bits/stdc++.h&gt; using namespace std; #define LOCAL #define ll long long const int N = 1e6 + 1, M = 21; const int mod = 1e9 + 7; int f[N][M]; int t; int n, m; int res, k; int prime[N]; bool st[N]; int cnt; void init() { for (int i = 2; i &lt;= 1000; i++) { if (!st[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++) { st[i * prime[j]] = true; if (i % prime[j] == 0) break; } } } signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif init(); f[0][0] = 1; for (int i = 1; i &lt; M; i++) f[0][i] = 2; for (int i = 1; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) if (j == 0) f[i][j] = 1; else f[i][j] = (f[i][j - 1] + f[i - 1][j]) % mod; } scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); res = 1; for (int i = 1; i &lt;= cnt; i++) { k = 0; if (m &lt; prime[i]) break; while (m % prime[i] == 0) { m /= prime[i]; k++; } res = 1ll * res * f[n][k] % mod; } if (m &gt; 1) res = 1ll * res * f[n][1] % mod; printf(&quot;%d\\n&quot;, res); } return 0; } ","link":"https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/"}]}