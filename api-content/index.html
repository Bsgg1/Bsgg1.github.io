{"posts":[{"title":"牛客寒假集训营第一场补题(现场情况：9题)","content":"B：在%3意义下一样的数，在同一区间内分数的变化情况是一样的，考虑倍增去维护 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+10; int n,q; char s[N]; int st[3][N][21]; void init() { for(int i=0;i&lt;=20;i++) { for(int j=1;j&lt;=n;j++) { if(i==0) { if(s[j]=='W') st[0][j][i]=st[1][j][i]=st[2][j][i]=1; if(s[j]=='L') { st[1][j][i]=st[2][j][i]=-1; st[0][j][i]=0; } if(s[j]=='D') st[0][j][i]=st[1][j][i]=st[2][j][i]=0; } else { int mid=j+(1&lt;&lt;(i-1)); if(mid&gt;n) { for(int k=0;k&lt;3;k++) st[k][j][i]=st[k][j][i-1]; } else { for(int k=0;k&lt;3;k++) st[k][j][i]=st[k][j][i-1]+st[((k+st[k][j][i-1])%3+3)%3][mid][i-1]; } } } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;q); scanf(&quot;%s&quot;,s+1); init(); while(q--) { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); int l=a; while(l&lt;=b) { int j=0; while(l+(1&lt;&lt;j)-1&lt;=b) j++; j--; c+=st[c%3][l][j]; l=l+(1&lt;&lt;j); } cout&lt;&lt;c&lt;&lt;&quot;\\n&quot;; } return 0; } K:考虑当前位置是i，连续的三个岛是jkl，则dp(i,j,k,l)可以从dp(i-1,x,j,k)转移，再根据题目的要求进行转移 #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 10; int n; char c[N]; int f[N][4][4][4]; int main() { scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, c + 1); memset(f, -1, sizeof f); if (c[n] == 'G') { f[n][1][1][1] = 3; f[n][1][1][2] = 2; f[n][1][2][1] = 2; f[n][2][1][1] = 2; f[n][1][1][3] = 2; f[n][1][3][1] = 2; f[n][3][1][1] = 2; f[n][1][3][3] = 1; f[n][3][1][3] = 1; f[n][3][3][1] = 1; } else if (c[n] == 'R') { f[n][2][2][2] = 0; f[n][2][2][3] = 0; f[n][2][3][2] = 0; f[n][3][2][2] = 0; f[n][2][3][3] = 0; f[n][3][2][3] = 0; f[n][3][3][2] = 0; f[n][1][2][2] = 1; f[n][2][1][2] = 1; f[n][2][2][1] = 1; } else { f[n][3][3][3] = 0; f[n][3][2][1] = 1; f[n][3][1][2] = 1; f[n][1][2][3] = 1; f[n][1][3][2] = 1; f[n][2][1][3] = 1; f[n][2][3][1] = 1; } for (int i = n - 1; i &gt;= 3; i--) { if (c[i] == 'G') { for (int j = 1; j &lt;= 3; j++) { if (f[i + 1][1][1][j] != -1) f[i][1][1][1] = max(f[i][1][1][1], f[i + 1][1][1][j] + 1); if (f[i + 1][1][3][j] != -1) f[i][1][1][3] = max(f[i][1][1][3], f[i + 1][1][3][j] + 1); if (f[i + 1][3][1][j] != -1) f[i][1][3][1] = max(f[i][1][3][1], f[i + 1][3][1][j] + 1); if (f[i + 1][1][1][j] != -1) f[i][3][1][1] = max(f[i][3][1][1], f[i + 1][1][1][j]); if (f[i + 1][1][2][j] != -1) f[i][1][1][2] = max(f[i][1][1][2], f[i + 1][1][2][j] + 1); if (f[i + 1][2][1][j] != -1) f[i][1][2][1] = max(f[i][1][2][1], f[i + 1][2][1][j] + 1); if (f[i + 1][1][1][j] != -1) f[i][2][1][1] = max(f[i][2][1][1], f[i + 1][1][1][j]); if (f[i + 1][3][3][j] != -1) f[i][1][3][3] = max(f[i][1][3][3], f[i + 1][3][3][j] + 1); if (f[i + 1][1][3][j] != -1) f[i][3][1][3] = max(f[i][3][1][3], f[i + 1][1][3][j]); if (f[i + 1][3][1][j] != -1) f[i][3][3][1] = max(f[i][3][3][1], f[i + 1][3][1][j]); } } if (c[i] == 'R') { for (int j = 1; j &lt;= 3; j++) { if (f[i + 1][2][2][j] != -1) f[i][2][2][2] = max(f[i][2][2][2], f[i + 1][2][2][j] + 0); if (f[i + 1][2][3][j] != -1) f[i][2][2][3] = max(f[i][2][2][3], f[i + 1][2][3][j] + 0); if (f[i + 1][3][2][j] != -1) f[i][2][3][2] = max(f[i][2][3][2], f[i + 1][3][2][j] + 0); if (f[i + 1][2][2][j] != -1) f[i][3][2][2] = max(f[i][3][2][2], f[i + 1][2][2][j] + 0); if (f[i + 1][2][1][j] != -1) f[i][2][2][1] = max(f[i][2][2][1], f[i + 1][2][1][j]); if (f[i + 1][1][2][j] != -1) f[i][2][1][2] = max(f[i][2][1][2], f[i + 1][1][2][j]); if (f[i + 1][2][2][j] != -1) f[i][1][2][2] = max(f[i][1][2][2], f[i + 1][2][2][j] + 1); if (f[i + 1][3][3][j] != -1) f[i][2][3][3] = max(f[i][2][3][3], f[i + 1][3][3][j] + 0); if (f[i + 1][2][3][j] != -1) f[i][3][2][3] = max(f[i][3][2][3], f[i + 1][2][3][j] + 0); if (f[i + 1][3][2][j] != -1) f[i][3][3][2] = max(f[i][3][3][2], f[i + 1][3][2][j] + 0); } } if (c[i] == 'B') { for (int j = 1; j &lt;= 3; j++) { if (f[i + 1][3][3][j] != -1) f[i][3][3][3] = max(f[i][3][3][3], f[i + 1][3][3][j]); if (f[i + 1][1][2][j] != -1) f[i][3][1][2] = max(f[i][3][1][2], f[i + 1][1][2][j]); if (f[i + 1][2][1][j] != -1) f[i][3][2][1] = max(f[i][3][2][1], f[i + 1][2][1][j]); if (f[i + 1][3][2][j] != -1) f[i][1][3][2] = max(f[i][1][3][2], f[i + 1][3][2][j] + 1); if (f[i + 1][3][1][j] != -1) f[i][2][3][1] = max(f[i][2][3][1], f[i + 1][3][1][j]); if (f[i + 1][1][3][j] != -1) f[i][2][1][3] = max(f[i][2][1][3], f[i + 1][1][3][j]); if (f[i + 1][2][3][j] != -1) f[i][1][2][3] = max(f[i][1][2][3], f[i + 1][2][3][j] + 1); } } } int ans = -1; for (int i = 0; i &lt;= 3; i++) for (int j = 0; j &lt;= 3; j++) for (int p = 0; p &lt;= 3; p++) ans = max(ans, f[3][i][j][p]); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://Bsgg1.github.io/post/niu-ke-han-jia-ji-xun-ying-di-yi-chang-bu-ti-xian-chang-qing-kuang-9-ti/"},{"title":"2021济南ICPC补","content":"虽然已经过去很久了，不过这也是自己参加的第一次icpc，一直没有补题，今天突然想起来了，就把该会的写一写吧 D:考虑第一项为x，第i项是x+(i-1)*d，d是公差，然后很容易想到三分d，然后对于不同的d我们求得就是 x+(i-1)*d-ai，我们令数组ti表示ai-(i-1) d，然后就变成了经典的货仓选址问题，x等于ti的中位数就可以了 #include&lt;bits/stdc++.h&gt; using namespace std; #define in128 __int128 #define ll long long #define LOCAL int n; const int N=2e5+10; ll a[N]; ll c[N]; void print(in128 x) { if(x&gt;9) print(x/10); putchar(x%10+'0'); } in128 check(ll d) { for(int i=1;i&lt;=n;i++) { c[i]=a[i]-d*(i-1); } sort(c+1,c+n+1); ll k=c[(n+1)/2]; in128 res=0; for(int i=1;i&lt;=n;i++) res+=abs(c[i]-k); return res; } int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); #endif cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } in128 l=-1e13,r=1e13; while(l&lt;r) { ll mid=l+(r-l)/3; ll midmid=r-(r-l)/3; if(check(mid)&lt;=check(midmid)) r=midmid-1; else l=mid+1; } print(check(l)); return 0; } C：如果先手拿的是当前剩余的里边的最大的，后手一定拿的也是最大的，所以最大的一定是成对出现的，然后其次就要奇偶，如果价值ci的有偶数个那么就是两人各一半，反之就是先手多1变成偶数的情况，然后我们考虑从小到大取，对于当前取到的价值，如果说他有k个，k是奇数就先手多拿一个然后变成偶数，现在双方各取k/2个，可以发现价值大的是可以穿插在价值小的中间拿的，但是价值最大的一定是成对出现的 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int mod=998244353; map&lt;int,int&gt; mp; const int N=1e6+10; int fac[N],infac[N]; int c[N]; int qpw(int a,int b) { int res=1%mod; while(b) { if(b&amp;1) res=res*a%mod; a=a*a%mod; b&gt;&gt;=1; } return res; } void init() { fac[0]=1; for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%mod; infac[N-1]=qpw(fac[N-1],mod-2); for(int i=N-2;i&gt;=0;i--) infac[i]=infac[i+1]*(i+1)%mod; } int cal(int a,int b) { if(a&lt;b) return 0; return fac[a]*infac[b]%mod*infac[a-b]%mod; } signed main() { int n; init(); cin&gt;&gt;n; while(n--) { int x;cin&gt;&gt;x; c[x]++; } int sum=0,ans=1; for(int i=1;i&lt;N;i++) { if(c[i]){ int y=c[i]; ans=ans*fac[y]%mod*cal(sum+(y)/2,(y)/2)%mod; sum+=y; } } cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;; return 0; } ","link":"https://Bsgg1.github.io/post/2021-ji-nan-icpc-bu/"},{"title":"CF 767 div2(垃圾场傻逼题)","content":"A：排序后按从ram需求从小到大就可以了 #include&lt;bits/stdc++.h&gt; using namespace std; int t; const int N=110; int a[N],b[N]; struct node{ int a,b; bool operator&lt;(const node&amp;m) { return a&lt;m.a; } }st[N]; int n,k; int main() { cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].a; for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].b; sort(st+1,st+n+1); for(int i=1;i&lt;=n;i++) { if(k&lt;st[i].a) break; k+=st[i].b; } cout&lt;&lt;k&lt;&lt;&quot;\\n&quot;; } return 0; } B:偶数和奇数的gcd一定是1，所以把所有的奇数都变成偶数就可以了，特判只有一个奇数的情况 #include&lt;bits/stdc++.h&gt; using namespace std; int t; const int N=110; int a[N],b[N]; struct node{ int a,b; bool operator&lt;(const node&amp;m) { return a&lt;m.a; } }st[N]; int n,k; int main() { cin&gt;&gt;t; while(t--) { int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int k=b-a+1; if(b==a) { if(a==1) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); } else{ if(a%2==b%2&amp;&amp;a%2==1) k=k/2+1; else k=k/2; if(k&lt;=c) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } } return 0; } C：每次找到最大的mex，按照题意模拟就可以 #include &lt;bits/stdc++.h&gt; using namespace std; int t; #define LOCAL const int N = 2e5 + 10; int a[N]; int n, k; int cnt[N]; int f[N]; int res[N]; int ccnt; int ans[N]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;t); while (t--) { ccnt = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt;= n; i++) res[i] = ans[i] = f[i] = cnt[i] = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); res[a[i]]++; } int l = 0, r = 0; for (int i = 1; i &lt;= n; i++) { f[a[i]]++; while (f[l]) l++; if (!res[l]) { ans[++ccnt] = l; for (int j = r + 1; j &lt;= i; j++) f[a[j]] = 0, res[a[j]]--; r = i; l = 0; } } cout &lt;&lt; ccnt &lt;&lt; &quot;\\n&quot;; for (int i = 1; i &lt;= ccnt; i++) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); } return 0; } D:如果存在回文串，只需要考虑3+2，2+3，以及reverse的情况就可以了 #include&lt;bits/stdc++.h&gt; using namespace std; map&lt;string,vector&lt;int&gt;&gt; mp; set&lt;string&gt; se; int t,n; int main() { cin&gt;&gt;t; while(t--) { mp.clear(); se.clear(); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { string s;cin&gt;&gt;s; se.insert(s); mp[s].push_back(i); } bool f=false; for(auto &amp;[x,y]:mp) { string s=x; //cout&lt;&lt;x&lt;&lt;&quot;\\n&quot;; if(s.size()==3) { string s1=&quot;ab&quot;,s2=&quot;ab&quot;; s1[0]=s[2],s1[1]=s[1]; s2[0]=s[1],s2[1]=s[0]; if(se.count(s1)){ if(*mp[s1].begin()&lt;y.back()){ f=true; break; } } if(se.count(s2)) { if(*y.begin()&lt;mp[s2].back()){ f=true; break; } } } reverse(s.begin(),s.end()); if(se.count(s)) { f=true; break; } } if(f) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } E:一个长为偶数的框，每次选一个点的四个邻点，一定可以通过选几次不重复地全部覆盖掉这个框，画画图就看明白了 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1100; bool st[N][N]; int t,n; int main() { cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; memset(st,false,sizeof st); int ans=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { int x;cin&gt;&gt;x; if(!st[i-1][j]&amp;&amp;!st[i+1][j]&amp;&amp;!st[i][j-1]&amp;&amp;!st[i][j+1]) { ans^=x; st[i-1][j]=st[i+1][j]=st[i][j-1]=st[i][j+1]=true; } } } cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;; } return 0; } ","link":"https://Bsgg1.github.io/post/cf-767-div2la-ji-chang-sha-bi-ti/"},{"title":"Hobbits(傻逼计算几何题)","content":"做法：倒着扫一遍维护最高点(最高点不一定是高度最高的点，是覆盖面积最大的点)，然后判断于直线的交点即可 #include &lt;bits/stdc++.h&gt; #define x first #define y second using namespace std; const double eps = 1e-8; typedef pair&lt;double, double&gt; pdd; const int N=2e5+10; double operator*(pdd a, pdd b) { return a.x * b.y - a.y * b.x; } pdd operator-(pdd a,pdd b) { return {a.x-b.x,a.y-b.y}; } struct line { pdd st, ed; }li[N]; pdd poi[N]; int n; double h; int dcmp(double a, double b) { if (fabs(a - b) &lt;= eps) return 0; if (a &lt; b) return -1; return 1; } double getdis(pdd a,pdd b) { double dx=a.x-b.x,dy=a.y-b.y; return sqrt(dx*dx+dy*dy); } double cross(pdd a,pdd b) { return a*b; } pdd get_line_intersection(pdd p, pdd v, pdd q, pdd w) { auto u = p - q; double t = cross(w, u) / cross(v, w); return {p.x + v.x * t, p.y + v.y * t}; } pdd get_line_intersection(line a, line b) { return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st); } int main() { cin&gt;&gt;n&gt;&gt;h; for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;poi[i].x,&amp;poi[i].y); pdd mx=poi[n],eye={poi[n].x,poi[n].y+h}; double ans=0; for(int i=n-1;i&gt;=1;i--) { auto p1=mx-eye,p2=poi[i]-eye,p3=poi[i+1]-eye; int f1=dcmp(p1*p2,0),f2=dcmp(p1*p3,0); //cout&lt;&lt;f1&lt;&lt;&quot; &quot;&lt;&lt;f2&lt;&lt;&quot;\\n&quot;; if(f1&lt;=0&amp;&amp;f2&lt;=0) ans+=getdis(poi[i],poi[i+1]); else if(f1&lt;=0&amp;&amp;f2&gt;0) { pdd pp=get_line_intersection(line{eye,mx},line{poi[i],poi[i+1]}); ans+=getdis(pp,poi[i]); } if(f1&lt;=0) mx=poi[i]; } printf(&quot;%.6lf&quot;,ans); return 0; } ","link":"https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/"},{"title":"容斥原理","content":"容斥原理：∣\\mid∣ S-A⋃\\bigcup⋃B∣\\mid∣ =S-A-B+A⋂\\bigcap⋂B ","link":"https://Bsgg1.github.io/post/rong-chi-yuan-li/"},{"title":"cf round766 div2（四题待更）","content":"A： 首先考虑不可能的情况就是全部都是白色，如果有一个黑色就可以操作一行一列所以一定有解 如果r，c是黑ans为0 r，c所在的列或者行有一个黑就是1 否则就是2 #include &lt;bits/stdc++.h&gt; #define x first #define y second #define LOCAL #define int long long using namespace std; const int N = 550; using pii = pair&lt;int, int&gt;; pii que[N]; char f[N][N]; int t, n, k,m; signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m; int r,c;cin&gt;&gt;c&gt;&gt;r; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin&gt;&gt;f[i][j]; int k1=0,k2=0; int k3=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(f[i][j]=='B') k3++; for(int i=1;i&lt;=m;i++) if(f[c][i]=='B') k1++; for(int i=1;i&lt;=n;i++) if(f[i][r]=='B') k2++; //cout&lt;&lt;k1&lt;&lt;&quot; &quot;&lt;&lt;k2&lt;&lt;&quot;\\n&quot;; if(k3==0) puts(&quot;-1&quot;); else { if(f[c][r]=='B') puts(&quot;0&quot;); else if(k1||k2) puts(&quot;1&quot;); else puts(&quot;2&quot;); } } return 0; } B:舔狗的故事 做法：首先是舔狗先选位置，女神会坐在距离他最远的地方，所以求出每个位置的距离，排个序输出就好了 #include &lt;bits/stdc++.h&gt; #define x first #define y second #define LOCAL using namespace std; const int N = 550; using pii = pair&lt;int, int&gt;; pii que[N]; int t, n, k,m; vector&lt;int&gt; e; signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m; e.clear(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { e.push_back(max(max(i-1+j-1,abs(i-n)+j-1),max(abs(i-n)+abs(j-m),i-1+abs(j-m)))); } sort(e.begin(),e.end()); for(auto x:e) cout&lt;&lt;x&lt;&lt;&quot; &quot;; puts(&quot;&quot;); } return 0; } c: 素数除去2剩下的都是奇数，若想相邻两条边加起来还是素数，那么最终的形式只能是一条链，然后边权23交替就好 #include&lt;bits/stdc++.h&gt; #define LOCAL #define x first #define y second using namespace std; int t; int n; typedef pair&lt;int,int&gt; pii; const int N=1e5+10; int h[N],e[2*N],ne[2*N],idx; pii q[N]; int c[N]; map&lt;pii,int&gt; mp; int res; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void dfs(int u,int fa) { for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j==fa) continue; mp[{u,j}]=mp[{j,u}]=res; res=5-res; dfs(j,u); } } int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); #endif cin&gt;&gt;t; while(t--) { idx=0; mp.clear(); memset(h,-1,sizeof h); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) c[i]=0; bool fl=true; for(int i=1;i&lt;n;i++) { int x,y;cin&gt;&gt;x&gt;&gt;y; add(x,y),add(y,x); q[i]={x,y}; c[x]++,c[y]++; } int l; for(int i=1;i&lt;=n;i++) { if(c[i]&gt;2) { fl=false; break; } if(c[i]==1) l=i; } //cout&lt;&lt;l&lt;&lt;&quot;\\n&quot;; res=2; if(!fl) puts(&quot;-1&quot;); else { dfs(l,-1); for(int i=1;i&lt;n;i++) cout&lt;&lt;mp[q[i]]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); } } return 0; } d: 由于gcd(a,b)小于等于ab的最小值，所以我们可以考虑对于一个数x若未出现在序列中，如果存在在序列中的大于x的倍数的gcd是x，那么通过一系列gcd操作就可以得到这个数 #include &lt;bits/stdc++.h&gt; #define LOCAL #define x first #define y second using namespace std; int t; int n; typedef pair&lt;int, int&gt; pii; const int N = 1e6 + 10; bool st[N]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; st[x] = true; } int ans = 0; for (int i = 5e5; i; i--) { if (!st[i]) { int k = 0; for (int j = i; j &lt;= 1e6; j += i) if (st[j]) k = __gcd(k, j); if (k == i) ans++; } } cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; return 0; } ","link":"https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/"},{"title":"CF round 756 div2（未完待更）","content":"A: 考虑对于二进制的某一位，如果1的数量大于0的数量那么这一位就需要是1 #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; int c1[50], c2[50]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int t; cin &gt;&gt; t; while (t--) { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) c1[i] = c2[i] = 0; while (n--) { int x; cin &gt;&gt; x; for (int i = 0; i &lt; k; i++) { if (x % 2 == 1) c1[i]++; else c2[i]++; x /= 2; } } int a = 1, res = 0; for (int i = 0; i &lt; k; i++) { if (c1[i] &gt; c2[i]) res = res + a; a = a * 2; } cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; } return 0; } B: 很容易想到体中所说的匹配指的是存在两个一样的k，他们前边有a个数，后边有b个数，让a+b+1最大 然后我们发现长度就是n-dis(k1,k2) #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; const int N=2e5+10; vector&lt;int&gt; e[N]; int a[N]; int main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif int t; cin &gt;&gt; t; while (t--) { for(int i=1;i&lt;=150000;i++) e[i].clear(); int n, k; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) { int x;cin&gt;&gt;x; e[x].push_back(i); } int res=-1; for(int i=1;i&lt;=150000;i++) { if(e[i].size()&gt;=2) { k=0x3f3f3f3f; for(int j=1;j&lt;e[i].size();j++) { k=min(k,e[i][j]-e[i][j-1]); } res=max(res,n-k); } } cout&lt;&lt;res&lt;&lt;&quot;\\n&quot;; } return 0; } C：考虑第i个位置是从第j个位置转移来的，n3dp #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 550; int a[N], d[N], dp[N][N]; int n, l, k; int main() { cin &gt;&gt; n &gt;&gt; l &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; a[n + 1] = l; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; d[i]; d[n + 1] = 0; n++; memset(dp, 0x3f, sizeof dp); dp[1][0] = 0; for (int i = 2; i &lt;= n; i++){ for (int j = 0; j &lt;= k; j++){ dp[i][j] = dp[i - 1][j] + (a[i] - a[i - 1]) * d[i - 1]; for(int s=1;s&lt;i;s++) { if(j-(i-s-1)&lt;0) continue; dp[i][j]=min(dp[i][j],dp[s][j-(i-s-1)]+(a[i]-a[s])*d[s]); } } } int res=0x3f3f3f3f; for(int i=0;i&lt;=k;i++) res=min(res,dp[n][i]); cout&lt;&lt;res&lt;&lt;&quot;\\n&quot;; return 0; } ","link":"https://Bsgg1.github.io/post/cf-round-756/"},{"title":"积性函数，莫比乌斯反演(未完待更)","content":"积性函数的定义：如果对于一个函数F : N - R,对于任意互质的a与b都有F(ab)=F(a)f(b),则称F为积性函数 如果F与G都是积性函数，那么H(i)=F(i)G(i) 也是积性函数 如何求解积性函数？ n=p1q1 ×\\times× p2q2 ×\\times× p3q3 ⋯\\cdots⋯ ×\\times× pnqn 所以F(n)=F(p1q1) ×\\times× F(p2q2) ⋯\\cdots⋯ ×\\times× F(pnqn) 利用欧拉筛求F(1-n) f[1]=1; for(int i=2;i&lt;=n;i++) { if(!st[i]) prime[++cnt]=i;f[i]=cal_f(i,1); for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++) { st[i*prime[j]]=true; if(i%j==0) { cnt[i*prime[j]]=cnt[i]+1; f[i*prime[j]]=f[i]/cal_f(p[j],cnt[i])*cal_f(p[j],cnt[i*f[j]]); break; } cnt[i*f[j]]=1; f[i*prime[j]]=f[i]*cal_f(f[j],1); } } 练习 1.简单应用： 求 1n ⨁\\bigoplus⨁ 2n ⨁\\bigoplus⨁ ⋯\\cdots⋯ nn 定义函数F，F(i)=in,所以F是一个积性函数，可以预处理出来1-n的F值，然后进行求解 #include &lt;bits/stdc++.h&gt; #define LOCAL using namespace std; #define int long long const int N = 1e6 + 10; const int mod = 1e9 + 7; int f[N * 13], prime[N]; bool st[N * 13]; int c[N]; int cnt; int n; int qpw(int a, int b) { int res = 1; while (b) { if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; } return res; } void init() { for (int i = 2; i &lt;= n; i++) { if (!st[i]) prime[++cnt] = i, f[i] = qpw(i, n); for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) { st[prime[j] * i] = true; f[i * prime[j]] = f[i] * f[prime[j]] % mod; if (i % prime[j] == 0) break; } } } signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif f[1] = 1; cin &gt;&gt; n; init(); int res = 0; for (int i = 1; i &lt;= n; i++) res = (res ^ f[i]); cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; return 0; } 结论：F是一个积性函数的话，G=∑\\sum∑d∣\\mid∣nF(d)也是积性函数 题目：cf 757-E 题意：定义函数F0(n)=u*v==n&amp;&amp;gcd(u,v)==1的个数 很显然我们可以发现F0(n)=2k,k是n分解后的项数，所以F0是一个积性函数 Fr(n)=∑\\sum∑d∣\\mid∣n Fr-1(d) 根据推论所以Fr也是一个积性函数 对于Fr(n)=Fr(p1q1)⨁\\bigoplus⨁Fr(p2q2)⋯\\cdots⋯ Fr(pnqn) 然后可以发现对于形如Fr(p1q1)的求解是通过递归求得的，并且与p1无关，q最大是20，所以可以先预处理，然后进行求解 这个题在处理素数时可以只处理1000以内的素数，一个数最多有一个质因子是大于根号的 代码： #include &lt;bits/stdc++.h&gt; using namespace std; #define LOCAL #define ll long long const int N = 1e6 + 1, M = 21; const int mod = 1e9 + 7; int f[N][M]; int t; int n, m; int res, k; int prime[N]; bool st[N]; int cnt; void init() { for (int i = 2; i &lt;= 1000; i++) { if (!st[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++) { st[i * prime[j]] = true; if (i % prime[j] == 0) break; } } } signed main() { #if ONLINE_JUDGE #else freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif init(); f[0][0] = 1; for (int i = 1; i &lt; M; i++) f[0][i] = 2; for (int i = 1; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) if (j == 0) f[i][j] = 1; else f[i][j] = (f[i][j - 1] + f[i - 1][j]) % mod; } scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); res = 1; for (int i = 1; i &lt;= cnt; i++) { k = 0; if (m &lt; prime[i]) break; while (m % prime[i] == 0) { m /= prime[i]; k++; } res = 1ll * res * f[n][k] % mod; } if (m &gt; 1) res = 1ll * res * f[n][1] % mod; printf(&quot;%d\\n&quot;, res); } return 0; } 莫比乌斯反演： 莫比乌斯函数μ\\muμ(n)=(-1)k 如果n=p1 p2 p3 .. pk,反之就是0，n=1的时候为1 f与g是两个函数 f(n)=∑\\sum∑d∣\\mid∣n g(d),则 g(n)=∑\\sum∑d∣\\mid∣nμ\\muμ(n/d)×\\times×f(d) f与g是两个函数,存在N，当n大于N是f(n)=g(n)=0 f(n)=∑\\sum∑n∣\\mid∣m g(m),则 g(n)=∑\\sum∑n∣\\mid∣mμ\\muμ(m/n)×\\times×f(m) 狄利克雷卷积 :符合交换律与结合律 设f n-&gt;R g n-&gt;R是两个函数，则他们的狄利克雷卷积为(fg)(n)=∑\\sum∑d∣\\mid∣n f(d)g(n/d) 如果f和g都是积性函数，那么他们的狄利克雷卷积也是积性函数 f=g与1的狄利克雷卷积 -&gt; g=f与u的狄仁杰利克雷卷积 ε\\varepsilonε = u1 ε\\varepsilonε=∑\\sum∑d∣\\mid∣nu(d) d=11 σ\\sigmaσ=id * 1 ϕ\\phiϕ =uid 应用：杜教筛 M(n)=∑\\sum∑(1-n) u(i) (n范围1e11) M(n)=1-∑\\sum∑(2-n)M(n/i(下取整)) ","link":"https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/"}]}