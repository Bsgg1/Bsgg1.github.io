<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Bsgg1.github.io/</id>
    <title>松松的小窝</title>
    <updated>2022-01-14T13:00:55.291Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Bsgg1.github.io/"/>
    <link rel="self" href="https://Bsgg1.github.io/atom.xml"/>
    <subtitle>代码最终篇，无爱自然神</subtitle>
    <logo>https://Bsgg1.github.io/images/avatar.png</logo>
    <icon>https://Bsgg1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 松松的小窝</rights>
    <entry>
        <title type="html"><![CDATA[积性函数，莫比乌斯反演]]></title>
        <id>https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/</id>
        <link href="https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/">
        </link>
        <updated>2022-01-14T10:24:43.000Z</updated>
        <content type="html"><![CDATA[<p>积性函数的定义：如果对于一个函数F : N - R,对于任意互质的a与b都有F(ab)=F(a)f(b),则称F为积性函数<br>
如果F与G都是积性函数，那么H(i)=F(i)G(i) 也是积性函数<br>
如何求解积性函数？<br>
n=p1<sup>q1</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p2<sup>q2</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p3<sup>q3</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> pn<sup>qn</sup><br>
所以F(n)=F(p1<sup>q1</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(p2<sup>q2</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(pn<sup>qn</sup>)</p>
<p>利用欧拉筛求F(1-n)</p>
<pre><code class="language-cpp">f[1]=1;
for(int i=2;i&lt;=n;i++)
{
    if(!st[i]) prime[++cnt]=i;f[i]=cal_f(i,1);
    for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)
    {
        st[i*prime[j]]=true;
        if(i%j==0)
        {
            cnt[i*prime[j]]=cnt[i]+1;
            f[i*prime[j]]=f[i]/cal_f(p[j],cnt[i])*cal_f(p[j],cnt[i*f[j]]);
            break;
        }
        cnt[i*f[j]]=1;
        f[i*prime[j]]=f[i]*cal_f(f[j],1);
    }
}

</code></pre>
<p>练习<br>
1.简单应用：<br>
求 1<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 2<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> n<sup>n</sup><br>
定义函数F，F(i)=i<sup>n</sup>,所以F是一个积性函数，可以预处理出来1-n的F值，然后进行求解</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
#define int long long
const int N = 1e6 + 10;
const int mod = 1e9 + 7;
int f[N * 13], prime[N];
bool st[N * 13];
int c[N];
int cnt;
int n;
int qpw(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}
void init()
{
    for (int i = 2; i &lt;= n; i++)
    {
        if (!st[i])
            prime[++cnt] = i, f[i] = qpw(i, n);
        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)
        {
            st[prime[j] * i] = true;
            f[i * prime[j]] = f[i] * f[prime[j]] % mod;
            if (i % prime[j] == 0)
                break;
        }
    }
}

signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    f[1] = 1;
    cin &gt;&gt; n;
    init();
    int res = 0;
    for (int i = 1; i &lt;= n; i++)
        res = (res ^ f[i]);
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<p>结论：F是一个积性函数的话，G=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>nF(d)也是积性函数</p>
]]></content>
    </entry>
</feed>