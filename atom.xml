<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Bsgg1.github.io/</id>
    <title>松松的小窝</title>
    <updated>2022-02-16T15:16:58.011Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Bsgg1.github.io/"/>
    <link rel="self" href="https://Bsgg1.github.io/atom.xml"/>
    <subtitle>今年和女朋友能不能都拿牌呢？
</subtitle>
    <logo>https://Bsgg1.github.io/images/avatar.png</logo>
    <icon>https://Bsgg1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 松松的小窝</rights>
    <entry>
        <title type="html"><![CDATA[矩阵与高斯消元记录]]></title>
        <id>https://Bsgg1.github.io/post/ju-zhen-yu-gao-si-xiao-yuan-ji-lu/</id>
        <link href="https://Bsgg1.github.io/post/ju-zhen-yu-gao-si-xiao-yuan-ji-lu/">
        </link>
        <updated>2022-02-11T05:28:03.000Z</updated>
        <content type="html"><![CDATA[<p>https://ac.nowcoder.com/acm/problem/14607<br>
a_n=2<em>a_n-1+n<sup>2</sup><br>
得到4</em>4矩阵<br>
a_n=2a_n-1+(n-1)<sup>2</sup>+2(n-1)+1<br>
n<sup>2</sup>=(n-1)<sup>2</sup>+2(n-1)+1<br>
n=n-1+1<br>
1=1</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define int long long
const long long mod = 1e9 + 9;
struct matrix
{
    long long n, m;
    long long num[5][5];
    void clear() { memset(num, 0, sizeof(num)); }
};
matrix operator*(matrix a, matrix b)
{ //重载矩阵乘法
    matrix ans;
    ans.clear();
    ans.n = a.n, ans.m = b.m;
    for (int i = 0; i &lt; a.n; i++)
        for (int j = 0; j &lt; b.m; j++)
            for (int k = 0; k &lt; a.m; k++)
                ans.num[i][j] = ((ans.num[i][j] + a.num[i][k] * b.num[k][j] % mod) % mod + mod) % mod;
    return ans;
}
matrix qpw(matrix a, long long x)
{ //矩阵快速幂
    matrix ans;
    ans.clear();
    ans.n = ans.m = a.n;
    for (int i = 0; i &lt; a.n; i++)
        ans.num[i][i] = 1;
    while (x)
    {
        if (x &amp; 1)
            ans = ans * a;
        a = a * a;
        x &gt;&gt;= 1;
    }
    return ans;
}
matrix operator+(matrix a, matrix b)
{ //重载矩阵加法
    matrix ans;
    ans.clear();
    ans.n = a.n, ans.m = a.m;
    for (int i = 0; i &lt; a.n; i++)
        for (int j = 0; j &lt; a.m; j++)
            ans.num[i][j] = (a.num[i][j] + b.num[i][j]) % mod;
    return ans;
}
bool operator!=(matrix a, matrix b)
{
    if (a.n != b.n || a.m != b.m)
        return 1;
    for (int i = 1; i &lt;= a.n; i++)
        for (int j = 1; j &lt;= a.m; j++)
            if (a.num[i][j] != b.num[i][j])
                return 1;
    return 0;
}
matrix base, tran;
signed main()
{
    base.clear(), base.n = 1, base.m = 4;
    base.num[0][0] = 0, base.num[0][1] = 1, base.num[0][2] = -1, base.num[0][3] = 1;
    tran.clear(), tran.n = tran.m = 4;
    tran.num[0][0] = tran.num[2][1] = tran.num[2][0] = 2;
    tran.num[1][0] = tran.num[3][0] = tran.num[1][1] = tran.num[3][1] = tran.num[2][2] = tran.num[3][2] = tran.num[3][3] = 1;
    ll x;
    while (cin &gt;&gt; x)
    {

        cout &lt;&lt; (base * qpw(tran, x + 1)).num[0][0] % mod &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性代数相关]]></title>
        <id>https://Bsgg1.github.io/post/xian-xing-dai-shu-xiang-guan/</id>
        <link href="https://Bsgg1.github.io/post/xian-xing-dai-shu-xiang-guan/">
        </link>
        <updated>2022-02-09T13:52:49.000Z</updated>
        <content type="html"><![CDATA[<p>模板：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const long long mod=1e9+7;
struct matrix{
    int n,m;
    long long num[32][32];  //矩阵大小根据题目设置
    void clear(){memset(num,0,sizeof(num));}
};
matrix operator *(matrix a,matrix b){   //重载矩阵乘法
    matrix ans;
    ans.clear();
    ans.n = a.n,ans.m = b.m;
    for (int i = 0; i &lt; a.n; i++)
        for (int j = 0; j &lt; b.m; j++)
            for (int k = 0; k &lt; a.m; k++)
                ans.num[i][j] = (ans.num[i][j] + a.num[i][k] * b.num[k][j] % mod) % mod;
    return ans;
}
matrix qpw(matrix a, long long x){   //矩阵快速幂
    matrix ans; ans.clear();
    ans.n = ans.m = a.n;
    for (int i = 0; i &lt; a.n; i++)
        ans.num[i][i] = 1;
    while(x)
    {
        if (x &amp; 1) ans = ans * a;
        a = a * a;
        x &gt;&gt;= 1;
    }
    return ans;
}
int main()
{
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[土狗daisiki的日常坐牢]]></title>
        <id>https://Bsgg1.github.io/post/tu-gou-daisiki-de-ri-chang-zuo-lao/</id>
        <link href="https://Bsgg1.github.io/post/tu-gou-daisiki-de-ri-chang-zuo-lao/">
        </link>
        <updated>2022-02-07T06:32:56.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Bsgg1.github.io//post-images/1644215628068.jpg" alt="" loading="lazy"><br>
https://codeforces.com/contest/1508/problem/A<br>
Tag:字符串，思维构造<br>
题意：给三个由0和1构成的字符p_i，长度为2n，构造一个长度为3n的字符串S，让至少两个p是S的子序列<br>
思路：首先可以得出任意p_i的cnt_0或者cnt_1是大于等于n的，考虑为什么是三个p?抽屉原理，一定会有两个p同时满足cnt1或者cnt0大于等于n，这样我们就固定好了n的长度，剩下的长度是2n,直接放就可以</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
string s[3];
int f[3];
int t, n;
string check(int a, int b)
{
	char x;
	string ans;
	if (f[a] &gt;= n)
		x = '1';
	else
		x = '0';
	int l = 0, r = 0;
	for (int i = 1; i &lt;= n; i++)
	{
		while (l &lt; 2 * n &amp;&amp; s[a][l] != x)
			ans += s[a][l++];
		while (r &lt; 2 * n &amp;&amp; s[b][r] != x)
			ans += s[b][r++];
		l++, r++;
		ans += x;
	}
	while (l &lt; 2 * n)
		ans += s[a][l++];
	while (r &lt; 2 * n)
		ans += s[b][r++];
	return ans;
}
void solve()
{
	for (int i = 0; i &lt; 3; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			if (j == i)
				continue;
			if (f[i] &gt; n &amp;&amp; f[j] &lt; n)
				continue;
			if (f[i] &lt; n &amp;&amp; f[j] &gt; n)
				continue;
			string ss = check(i, j);
			if (ss.size() &lt;= n * 3)
			{
				cout &lt;&lt; ss &lt;&lt; &quot;\n&quot;;
				return;
			}
		}
	}
}
int main()
{
	cin &gt;&gt; t;
	while (t--)
	{
		cin &gt;&gt; n;
		f[0] = f[1] = f[2] = 0;
		for (int i = 0; i &lt; 3; i++)
		{
			cin &gt;&gt; s[i];
			for (int j = 0; j &lt; 2 * n; j++)
				if (s[i][j] == '1')
					f[i]++;
		}
		solve();
	}

	return 0;
}
</code></pre>
<p>https://codeforces.com/contest/1381/problem/A2<br>
Tag：思维<br>
字符串a，b，对a进行下列操作至多2n次使得a变成b，操作：选长度为k的前缀，其中0变成1，1变成0，并且翻转<br>
思路：讲a变为全0或者全1至多n次，然后考虑倒着匹配b，至多反转n次</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10;
vector&lt;int&gt; v;
char s1[N],s2[N];
int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        int n;
        v.clear();
        scanf(&quot;%d%s%s&quot;,&amp;n,s1+1,s2+1);
        if (n == 1)
           {
               if(s1[1]==s2[1]) puts(&quot;0&quot;);
               else puts(&quot;1 1&quot;);
           }
        else
        {
            char r=s1[n];
            for (int i = 2; i &lt;=n; i++)
            {
                if (s1[i] != s1[i - 1])
                {
                    v.push_back(i-1);
                }
            }
            for(int i=n;i&gt;=1;i--)
            {
                if(s2[i]!=r)
                {
                    v.push_back(i);
                    r='1'-r+'0';
                    //cout&lt;&lt;r&lt;&lt;&quot;\n&quot;;
                }
            }
            cout&lt;&lt;v.size()&lt;&lt;&quot; &quot;;
            for(auto x:v) cout&lt;&lt;x&lt;&lt;&quot; &quot;;
            puts(&quot;&quot;);
        }
    }

    return 0;
}
</code></pre>
<p>https://codeforces.com/contest/1381/problem/B<br>
Tag:思维转化后就是01背包<br>
首先通过题意可以分析出连续减小的一段区间一定是属于一个数组的，然后就可以把连续下降的长度分别求出来，然后dp能不能得到n就好了</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 4e3 + 10;
int f[N], p[N], tot;
int dp[N];
int main()
{
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        int n;
        cin &gt;&gt; n;
        tot = 0;
        memset(dp, -1, sizeof dp);
        for (int i = 1; i &lt;= 2 * n; i++)
            cin &gt;&gt; f[i];
        for (int l = 1, r; l &lt;= 2 * n; l = r + 1)
        {
            r = l;
            while (r &lt;= 2 * n &amp;&amp; f[r] &lt;= f[l])
                r++;
            r--;
            p[tot++] = r - l + 1;
            if (r == 2 * n)
                break;
        }
        memset(dp, -0x3f3f3f3f, sizeof(dp));
        dp[0] = 0;
        for (int i = 0; i &lt; tot; i++)
        {
            for (int j = n; j &gt;= p[i]; j--)
            {

                dp[j] = max(dp[j], dp[j - p[i]] + p[i]);
            }
        }
        if (dp[n] &gt; 0)
            puts(&quot;YES&quot;);
        else
            puts(&quot;NO&quot;);
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串相关(持续更新)]]></title>
        <id>https://Bsgg1.github.io/post/zi-fu-chuan-xiang-guan-chi-xu-geng-xin/</id>
        <link href="https://Bsgg1.github.io/post/zi-fu-chuan-xiang-guan-chi-xu-geng-xin/">
        </link>
        <updated>2022-01-28T10:24:22.000Z</updated>
        <content type="html"><![CDATA[<p>1.字符串的Border,如果字符串S的同长度的前缀与后缀完全相同，则称此前缀为一个border<br>
例如：S=bbabbab,则他的border有b,bbab,字符串本身也可以是border，具体根据题意判断<br>
2.周期与循环节<br>
用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>代表s的长度，下标从1开始<br>
对于p，如果满足p &lt; i <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> 都有s(i)=s(i-p),那么p是s的一个周期<br>
特别：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>也是s的一个周期<br>
循环节：若字符串的周期满足 p<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> ,则p是s的循环节<br>
特别：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>也是s的循环节<br>
结论：<br>
p是s的周期<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⟸</mo></mrow><annotation encoding="application/x-tex">\Longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟸</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>-p是s的border<br>
传递性S的border的border也是S的border<br>
求S的所有border等价于求S的所有前缀的最大border<br>
KMP<br>
next数组：<br>
next(i)=preffix(i)的非平凡的最大border(非平凡指去掉本身)<br>
next(1)=0<br>
考虑preffix(i)的大于1的border，去掉最后一个就变成了preffix(i-1)的border，所以求next(i)的时候，遍历preffix(i-1)的所有border，即next(i-1),next(next(i-1))....0,验证后一个字符是不是等于s(i)即可</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
const int N = 1000010;
char a[N], b[N];
int nxt[N], n, m;

void kmp_nxt(char *s)
{
    for (int i = 2, j = 0; i &lt;= m; ++i)
    {

        nxt[i] = nxt[i - 1];
        while (nxt[i] &amp;&amp; s[i] != s[nxt[i] + 1])
            nxt[i] = nxt[nxt[i]];
        nxt[i] += (s[i] == s[nxt[i] + 1]);
    }
}

void solve() 
{
    scanf(&quot;%s%s&quot;, a + 1, b + 1);
    n = strlen(a + 1), m = strlen(b + 1);
    kmp_nxt(b);
    for (int i = 1, j = 0; i &lt;= n; ++i)
    {
        while (j &amp;&amp; a[i] != b[j + 1])
            j = nxt[j];
        if (a[i] == b[j + 1])
            ++j;
        if (j == m)
        {
            printf(&quot;%d\n&quot;, i - j + 1);
        }
    }

    for (int i = 1; i &lt;= m; ++i)
        printf(&quot;%d &quot;, nxt[i]);
}

int main()
{
    int _ = 1;
    while (_--)
        solve();
    return 0;
}
</code></pre>
<p>例题：<br>
对于字符串S，求他的最长子串p，满足p是S的前缀，p是S的后缀，同时p至少在S中出现三次<br>
思路：首先p是S的border，可以通过kmp求出，由于p要最长且出现三次，可以确定答案一定在nxt(n)与nxt(nxt(n))之间，因为nxt(nxt(n))在S中至少出现了四次，所以答案就在这两个里边，注意特判掉不存在的情况</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int nxt[N];
int len;
void kmp()
{
	nxt[1]=0;
	for(int i=2;i&lt;=len;i++)
	{
		nxt[i]=nxt[i-1];
		while(nxt[i]&amp;&amp;s[i]!=s[nxt[i]+1]) nxt[i]=nxt[nxt[i]];
		nxt[i]+=(s[i]==s[nxt[i]+1]);
	}
}
int main()
{
	scanf(&quot;%s&quot;,s+1);
	len=strlen(s+1);
	kmp();
	if(nxt[len]==0) 
	{
		puts(&quot;Just a legend&quot;);
	}
	else
	{
		bool f=false;
		for(int i=1;i&lt;len;i++) if(nxt[i]==nxt[len]) {f=true;break;}
		if(f) for(int i=1;i&lt;=nxt[len];i++) cout&lt;&lt;s[i];
		else{ 
            if(nxt[nxt[len]])
            for(int i=1;i&lt;=nxt[nxt[len]];i++) cout&lt;&lt;s[i];
            else puts(&quot;Just a legend&quot;);
        }

	}

	return 0;
}
</code></pre>
<p>Border的性质：<br>
周期定理：若p,q都是S的周期，那么gcd(p,q)，也是S的周期<br>
一个串的Border数量是O(n)个，但是他们组成了(logN)个等差数列<br>
Border树：<br>
对于一个字符串S，他的border树(nxt树)共有n+1个节点<br>
0是根节点，对于其他节点i的父节点是nxt(i)<br>
性质：<br>
每个前缀的所有border，节点i到根的链<br>
哪些前缀有长度为x的border：x的子树<br>
求两个前缀的公共border等于求LCA</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客寒假集训营第一场补题(现场情况：9题)]]></title>
        <id>https://Bsgg1.github.io/post/niu-ke-han-jia-ji-xun-ying-di-yi-chang-bu-ti-xian-chang-qing-kuang-9-ti/</id>
        <link href="https://Bsgg1.github.io/post/niu-ke-han-jia-ji-xun-ying-di-yi-chang-bu-ti-xian-chang-qing-kuang-9-ti/">
        </link>
        <updated>2022-01-25T07:38:13.000Z</updated>
        <content type="html"><![CDATA[<p>B：在%3意义下一样的数，在同一区间内分数的变化情况是一样的，考虑倍增去维护</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+10;
int n,q;
char s[N];
int st[3][N][21];
void init()
{
    for(int i=0;i&lt;=20;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            if(i==0)
            {
                if(s[j]=='W') st[0][j][i]=st[1][j][i]=st[2][j][i]=1;
                if(s[j]=='L')
                {
                    st[1][j][i]=st[2][j][i]=-1;
                    st[0][j][i]=0;
                }
                if(s[j]=='D')
                st[0][j][i]=st[1][j][i]=st[2][j][i]=0;
            }
            else
            {
                int mid=j+(1&lt;&lt;(i-1));
                if(mid&gt;n)
                {
                    for(int k=0;k&lt;3;k++) 
                    st[k][j][i]=st[k][j][i-1];
                }
                else
                {
                    for(int k=0;k&lt;3;k++)
                    st[k][j][i]=st[k][j][i-1]+st[((k+st[k][j][i-1])%3+3)%3][mid][i-1];
                }
            }
        }
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    scanf(&quot;%s&quot;,s+1);
    init();
    while(q--)
    {
        int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        int l=a;
        while(l&lt;=b)
        {
            int j=0;
            while(l+(1&lt;&lt;j)-1&lt;=b) j++;
            j--;
            c+=st[c%3][l][j];
            l=l+(1&lt;&lt;j);
        }
        cout&lt;&lt;c&lt;&lt;&quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<p>K:考虑当前位置是i，连续的三个岛是jkl，则dp(i,j,k,l)可以从dp(i-1,x,j,k)转移，再根据题目的要求进行转移</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
int n;
char c[N];
int f[N][4][4][4];
int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%s&quot;, c + 1);
    memset(f, -1, sizeof f);
    if (c[n] == 'G')
    {
        f[n][1][1][1] = 3;
        f[n][1][1][2] = 2;
        f[n][1][2][1] = 2;
        f[n][2][1][1] = 2;
        f[n][1][1][3] = 2;
        f[n][1][3][1] = 2;
        f[n][3][1][1] = 2;
        f[n][1][3][3] = 1;
        f[n][3][1][3] = 1;
        f[n][3][3][1] = 1;
    }
    else if (c[n] == 'R')
    {
        f[n][2][2][2] = 0;
        f[n][2][2][3] = 0;
        f[n][2][3][2] = 0;
        f[n][3][2][2] = 0;
        f[n][2][3][3] = 0;
        f[n][3][2][3] = 0;
        f[n][3][3][2] = 0;
        f[n][1][2][2] = 1;
        f[n][2][1][2] = 1;
        f[n][2][2][1] = 1;
    }
    else
    {
        f[n][3][3][3] = 0;
        f[n][3][2][1] = 1;
        f[n][3][1][2] = 1;
        f[n][1][2][3] = 1;
        f[n][1][3][2] = 1;
        f[n][2][1][3] = 1;
        f[n][2][3][1] = 1;
    }
    for (int i = n - 1; i &gt;= 3; i--)
    {
        if (c[i] == 'G')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][1][1][j] != -1)
                    f[i][1][1][1] = max(f[i][1][1][1], f[i + 1][1][1][j] + 1);
                if (f[i + 1][1][3][j] != -1)
                    f[i][1][1][3] = max(f[i][1][1][3], f[i + 1][1][3][j] + 1);
                if (f[i + 1][3][1][j] != -1)
                    f[i][1][3][1] = max(f[i][1][3][1], f[i + 1][3][1][j] + 1);
                if (f[i + 1][1][1][j] != -1)
                    f[i][3][1][1] = max(f[i][3][1][1], f[i + 1][1][1][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][1][1][2] = max(f[i][1][1][2], f[i + 1][1][2][j] + 1);
                if (f[i + 1][2][1][j] != -1)
                    f[i][1][2][1] = max(f[i][1][2][1], f[i + 1][2][1][j] + 1);
                if (f[i + 1][1][1][j] != -1)
                    f[i][2][1][1] = max(f[i][2][1][1], f[i + 1][1][1][j]);
                if (f[i + 1][3][3][j] != -1)
                    f[i][1][3][3] = max(f[i][1][3][3], f[i + 1][3][3][j] + 1);
                if (f[i + 1][1][3][j] != -1)
                    f[i][3][1][3] = max(f[i][3][1][3], f[i + 1][1][3][j]);
                if (f[i + 1][3][1][j] != -1)
                    f[i][3][3][1] = max(f[i][3][3][1], f[i + 1][3][1][j]);
            }
        }
        if (c[i] == 'R')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][2][2][j] != -1)
                    f[i][2][2][2] = max(f[i][2][2][2], f[i + 1][2][2][j] + 0);
                if (f[i + 1][2][3][j] != -1)
                    f[i][2][2][3] = max(f[i][2][2][3], f[i + 1][2][3][j] + 0);
                if (f[i + 1][3][2][j] != -1)
                    f[i][2][3][2] = max(f[i][2][3][2], f[i + 1][3][2][j] + 0);
                if (f[i + 1][2][2][j] != -1)
                    f[i][3][2][2] = max(f[i][3][2][2], f[i + 1][2][2][j] + 0);
                if (f[i + 1][2][1][j] != -1)
                    f[i][2][2][1] = max(f[i][2][2][1], f[i + 1][2][1][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][2][1][2] = max(f[i][2][1][2], f[i + 1][1][2][j]);
                if (f[i + 1][2][2][j] != -1)
                    f[i][1][2][2] = max(f[i][1][2][2], f[i + 1][2][2][j] + 1);
                if (f[i + 1][3][3][j] != -1)
                    f[i][2][3][3] = max(f[i][2][3][3], f[i + 1][3][3][j] + 0);
                if (f[i + 1][2][3][j] != -1)
                    f[i][3][2][3] = max(f[i][3][2][3], f[i + 1][2][3][j] + 0);
                if (f[i + 1][3][2][j] != -1)
                    f[i][3][3][2] = max(f[i][3][3][2], f[i + 1][3][2][j] + 0);
            }
        }
        if (c[i] == 'B')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][3][3][j] != -1)
                    f[i][3][3][3] = max(f[i][3][3][3], f[i + 1][3][3][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][3][1][2] = max(f[i][3][1][2], f[i + 1][1][2][j]);
                if (f[i + 1][2][1][j] != -1)
                    f[i][3][2][1] = max(f[i][3][2][1], f[i + 1][2][1][j]);
                if (f[i + 1][3][2][j] != -1)
                    f[i][1][3][2] = max(f[i][1][3][2], f[i + 1][3][2][j] + 1);
                if (f[i + 1][3][1][j] != -1)
                    f[i][2][3][1] = max(f[i][2][3][1], f[i + 1][3][1][j]);
                if (f[i + 1][1][3][j] != -1)
                    f[i][2][1][3] = max(f[i][2][1][3], f[i + 1][1][3][j]);
                if (f[i + 1][2][3][j] != -1)
                    f[i][1][2][3] = max(f[i][1][2][3], f[i + 1][2][3][j] + 1);
            }
        }
    }
    int ans = -1;
    for (int i = 0; i &lt;= 3; i++)
        for (int j = 0; j &lt;= 3; j++)
            for (int p = 0; p &lt;= 3; p++)
                ans = max(ans, f[3][i][j][p]);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021济南ICPC补]]></title>
        <id>https://Bsgg1.github.io/post/2021-ji-nan-icpc-bu/</id>
        <link href="https://Bsgg1.github.io/post/2021-ji-nan-icpc-bu/">
        </link>
        <updated>2022-01-23T10:37:26.000Z</updated>
        <content type="html"><![CDATA[<p>虽然已经过去很久了，不过这也是自己参加的第一次icpc，一直没有补题，今天突然想起来了，就把该会的写一写吧<br>
D:考虑第一项为x，第i项是x+(i-1)*d，d是公差，然后很容易想到三分d，然后对于不同的d我们求得就是<br>
x+(i-1)*d-ai，我们令数组ti表示ai-(i-1) d，然后就变成了经典的货仓选址问题，x等于ti的中位数就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define in128 __int128
#define ll long long
#define LOCAL
int n;
const int N=2e5+10;
ll a[N];
ll c[N];
void print(in128 x)
{
	if(x&gt;9) print(x/10);
	putchar(x%10+'0');
}
in128 check(ll d)
{
	for(int i=1;i&lt;=n;i++)
	{
		c[i]=a[i]-d*(i-1);
	}
	sort(c+1,c+n+1);
	ll k=c[(n+1)/2];
	in128 res=0;
	for(int i=1;i&lt;=n;i++)
	res+=abs(c[i]-k);
	return res;
}
int main()
{
	#if ONLINE_JUDGE
	#else
	freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
	freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
	#endif
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
	}
	in128 l=-1e13,r=1e13;
	while(l&lt;r)
	{
		ll mid=l+(r-l)/3;
		ll midmid=r-(r-l)/3;
		if(check(mid)&lt;=check(midmid)) r=midmid-1;
		else l=mid+1;
	}
	print(check(l));
	return 0;
}

</code></pre>
<p>C：如果先手拿的是当前剩余的里边的最大的，后手一定拿的也是最大的，所以最大的一定是成对出现的，然后其次就要奇偶，如果价值ci的有偶数个那么就是两人各一半，反之就是先手多1变成偶数的情况，然后我们考虑从小到大取，对于当前取到的价值，如果说他有k个，k是奇数就先手多拿一个然后变成偶数，现在双方各取k/2个，可以发现价值大的是可以穿插在价值小的中间拿的，但是价值最大的一定是成对出现的</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int mod=998244353;
map&lt;int,int&gt; mp;
const int N=1e6+10;
int fac[N],infac[N];
int c[N];
int qpw(int a,int b)
{
    int res=1%mod;
    while(b)
    {
        if(b&amp;1) res=res*a%mod;
        a=a*a%mod;
        b&gt;&gt;=1;
    }
    return res;
}
void init()
{
    fac[0]=1;
    for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%mod;
    infac[N-1]=qpw(fac[N-1],mod-2);
    for(int i=N-2;i&gt;=0;i--) infac[i]=infac[i+1]*(i+1)%mod;
}
int cal(int a,int b)
{
    if(a&lt;b) return 0;
    return fac[a]*infac[b]%mod*infac[a-b]%mod;
}
signed main()
{
    int n;
    init();
    cin&gt;&gt;n;
    while(n--)
    {
        int x;cin&gt;&gt;x;
        c[x]++;
    }
    int sum=0,ans=1;
    for(int i=1;i&lt;N;i++)
    {
        if(c[i]){
            int y=c[i];
        ans=ans*fac[y]%mod*cal(sum+(y)/2,(y)/2)%mod;
        sum+=y;
        }
    }
    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 767 div2(垃圾场傻逼题)]]></title>
        <id>https://Bsgg1.github.io/post/cf-767-div2la-ji-chang-sha-bi-ti/</id>
        <link href="https://Bsgg1.github.io/post/cf-767-div2la-ji-chang-sha-bi-ti/">
        </link>
        <updated>2022-01-23T07:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>A：排序后按从ram需求从小到大就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t;
const int N=110;
int a[N],b[N];
struct node{
	int a,b;
	bool operator&lt;(const node&amp;m)
	{
		return a&lt;m.a;
	}
}st[N];
int n,k;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		cin&gt;&gt;n&gt;&gt;k;
		for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].a;
		for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].b;
		sort(st+1,st+n+1);
		for(int i=1;i&lt;=n;i++)
		{
			if(k&lt;st[i].a) break;
			k+=st[i].b;
		}
		cout&lt;&lt;k&lt;&lt;&quot;\n&quot;;
	}
	return 0;
}
</code></pre>
<p>B:偶数和奇数的gcd一定是1，所以把所有的奇数都变成偶数就可以了，特判只有一个奇数的情况</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t;
const int N=110;
int a[N],b[N];
struct node{
	int a,b;
	bool operator&lt;(const node&amp;m)
	{
		return a&lt;m.a;
	}
}st[N];
int n,k;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
		int k=b-a+1;
		if(b==a)
		{
		    if(a==1) puts(&quot;NO&quot;);
		    else puts(&quot;YES&quot;);
		}
		else{
		if(a%2==b%2&amp;&amp;a%2==1) k=k/2+1;
		else k=k/2;
		if(k&lt;=c) puts(&quot;YES&quot;);
		else puts(&quot;NO&quot;);
		}
	}
	return 0;
}
</code></pre>
<p>C：每次找到最大的mex，按照题意模拟就可以</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int t;
#define LOCAL
const int N = 2e5 + 10;
int a[N];
int n, k;
int cnt[N];
int f[N];
int res[N];
int ccnt;
int ans[N];
int main()
{
#if ONLINE_JUDGE
#else
	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
	scanf(&quot;%d&quot;, &amp;t);
	while (t--)
	{
		ccnt = 0;
		scanf(&quot;%d&quot;, &amp;n);
		for (int i = 0; i &lt;= n; i++)
			res[i] = ans[i] = f[i] = cnt[i] = 0;
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			res[a[i]]++;
		}
		int l = 0, r = 0;
		for (int i = 1; i &lt;= n; i++)
		{
			f[a[i]]++;
			while (f[l])
				l++;
			if (!res[l])
			{
				ans[++ccnt] = l;
				for (int j = r + 1; j &lt;= i; j++)
					f[a[j]] = 0, res[a[j]]--;
				r = i;
				l = 0;
			}
		}
		cout &lt;&lt; ccnt &lt;&lt; &quot;\n&quot;;
		for (int i = 1; i &lt;= ccnt; i++)
			cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<p>D:如果存在回文串，只需要考虑3+2，2+3，以及reverse的情况就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string,vector&lt;int&gt;&gt; mp;
set&lt;string&gt; se;
int t,n;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		mp.clear();
		se.clear();
		cin&gt;&gt;n;
		for(int i=1;i&lt;=n;i++)
		{
			string s;cin&gt;&gt;s;
			se.insert(s);
			mp[s].push_back(i);
		}
		bool f=false;
		for(auto &amp;[x,y]:mp)
		{
			string s=x;
			//cout&lt;&lt;x&lt;&lt;&quot;\n&quot;;
			if(s.size()==3)
			{
				string s1=&quot;ab&quot;,s2=&quot;ab&quot;;
				s1[0]=s[2],s1[1]=s[1];
				s2[0]=s[1],s2[1]=s[0];
				if(se.count(s1)){
				if(*mp[s1].begin()&lt;y.back()){
				f=true;
				break;
				}
				}
				if(se.count(s2))
				{
				if(*y.begin()&lt;mp[s2].back()){
				f=true;
				break;
				}
				}
			}
			reverse(s.begin(),s.end());
			if(se.count(s))
			{
				f=true;
				break;
			}
		}
		if(f) puts(&quot;YES&quot;);
		else puts(&quot;NO&quot;);
	}
	return 0;
}
</code></pre>
<p>E:一个长为偶数的框，每次选一个点的四个邻点，一定可以通过选几次不重复地全部覆盖掉这个框，画画图就看明白了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1100;
bool st[N][N];
int t,n;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		cin&gt;&gt;n;
		memset(st,false,sizeof st);
		int ans=0;
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=n;j++)
			{
				int x;cin&gt;&gt;x;
				if(!st[i-1][j]&amp;&amp;!st[i+1][j]&amp;&amp;!st[i][j-1]&amp;&amp;!st[i][j+1])
				{
					ans^=x;
					st[i-1][j]=st[i+1][j]=st[i][j-1]=st[i][j+1]=true;
				}
			}
		}
		cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
	}


	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hobbits(傻逼计算几何题)]]></title>
        <id>https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/</id>
        <link href="https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/">
        </link>
        <updated>2022-01-21T13:11:24.000Z</updated>
        <content type="html"><![CDATA[<p>做法：倒着扫一遍维护最高点(最高点不一定是高度最高的点，是覆盖面积最大的点)，然后判断于直线的交点即可</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
const double eps = 1e-8;
typedef pair&lt;double, double&gt; pdd;
const int N=2e5+10;
double operator*(pdd a, pdd b)
{
    return a.x * b.y - a.y * b.x;
}
pdd operator-(pdd a,pdd b)
{
    return {a.x-b.x,a.y-b.y};
}
struct line
{
    pdd st, ed;
}li[N];
pdd poi[N];
int n;
double h;
int dcmp(double a, double b)
{
    if (fabs(a - b) &lt;= eps)
        return 0;
    if (a &lt; b)
        return -1;
    return 1;
}
double getdis(pdd a,pdd b)
{
    double dx=a.x-b.x,dy=a.y-b.y;
    return sqrt(dx*dx+dy*dy);
}
double cross(pdd a,pdd b)
{
    return a*b;
}
pdd get_line_intersection(pdd p, pdd v, pdd q, pdd w)
{
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

pdd get_line_intersection(line a, line b)
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;h;
    for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;poi[i].x,&amp;poi[i].y);
    pdd mx=poi[n],eye={poi[n].x,poi[n].y+h};
    double ans=0;
    for(int i=n-1;i&gt;=1;i--)
    {
        auto p1=mx-eye,p2=poi[i]-eye,p3=poi[i+1]-eye;
        int f1=dcmp(p1*p2,0),f2=dcmp(p1*p3,0);
        //cout&lt;&lt;f1&lt;&lt;&quot; &quot;&lt;&lt;f2&lt;&lt;&quot;\n&quot;;
        if(f1&lt;=0&amp;&amp;f2&lt;=0)
        ans+=getdis(poi[i],poi[i+1]);
        else if(f1&lt;=0&amp;&amp;f2&gt;0)
        {
            pdd pp=get_line_intersection(line{eye,mx},line{poi[i],poi[i+1]});
            ans+=getdis(pp,poi[i]);
        }
        if(f1&lt;=0) mx=poi[i];
    }
    printf(&quot;%.6lf&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[容斥原理]]></title>
        <id>https://Bsgg1.github.io/post/rong-chi-yuan-li/</id>
        <link href="https://Bsgg1.github.io/post/rong-chi-yuan-li/">
        </link>
        <updated>2022-01-17T07:03:05.000Z</updated>
        <content type="html"><![CDATA[<p>容斥原理：<br>
设S是一个有限集，A1,A2....An是S的n个子集<br>
则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> S- <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span></span></span></span>Ai<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=0}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span>(-1)<sup>i</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{j=0}^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>k=1-n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋂</mo></mrow><annotation encoding="application/x-tex">\bigcap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span></span></span></span> A_jk<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span><br>
题目：<br>
https://ac.nowcoder.com/acm/problem/230894<br>
容斥经典问题：不定方程的解的数量<br>
x1+x2+x3+....+xn=m的数量 xi&gt;=0，xi&lt;=ai<br>
首先不考虑上限，那么就可以考虑为隔板问题，因为可以等于0，考虑+n个虚球，那么现在就是m+n个球，隔板，共m+n-1个空，n-1个板，直接组合数，然后考虑上限，si为第i个球大于ai的情况，由容斥原理，就可以求出结果<br>
考虑si怎么求：大于ai，那么最少拿ai+1+k，那么原式中的ai变成k，m变成m-ai-1，仍可以组合数求<br>
复杂度O(2<sup>N</sup>*N)</p>
<pre><code class="language-CPP">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N=25;
int n,m;
const int mod=1e9+7;
int fac[N],infac[N];
int a[N];
int d;
int qpw(int a,int b)
{
    int res=1%mod;
    while(b)
    {
        if(b&amp;1) res=res*a%mod;
        a=a*a%mod;
        b&gt;&gt;=1;
    }
    return res;
}
void init()
{
    fac[0]=1;for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%mod;
    infac[N-1]=qpw(fac[N-1],mod-2);
    for(int i=N-2;i&gt;=0;i--) infac[i]=infac[i+1]*(i+1)%mod;
}
int cal(int n,int m)
{
    if(n&lt;m) return 0;
    int res=1;
    for(int i=0;i&lt;m;i++) res=((n-i)%mod*res%mod+mod)%mod;
    return res*infac[m]%mod;
}
signed main()
{
    init();
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
    int res=0;
    for(int i=0;i&lt;(1&lt;&lt;n);i++)
    {
        int sign=1,sum=m+n-1,p=n-1;
        for(int j=0;j&lt;n;j++)
        {
            if((i&gt;&gt;j)&amp;1)
            {
                sum-=a[j]+1;
                sign*=-1;
            }
        }
        res=((res+sign*cal(sum,p))%mod+mod)%mod;
    }
    cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;


    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cf round766 div2（四题待更）]]></title>
        <id>https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/</id>
        <link href="https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/">
        </link>
        <updated>2022-01-15T16:44:34.000Z</updated>
        <content type="html"><![CDATA[<p>A：<br>
首先考虑不可能的情况就是全部都是白色，如果有一个黑色就可以操作一行一列所以一定有解<br>
如果r，c是黑ans为0<br>
r，c所在的列或者行有一个黑就是1<br>
否则就是2</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
#define LOCAL
#define int long long
using namespace std;
const int N = 550;
using pii = pair&lt;int, int&gt;;
pii que[N];
char f[N][N];
int t, n, k,m;
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        int r,c;cin&gt;&gt;c&gt;&gt;r;
        for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        cin&gt;&gt;f[i][j];
        int k1=0,k2=0;
        int k3=0;
        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(f[i][j]=='B') k3++;
        for(int i=1;i&lt;=m;i++)
        if(f[c][i]=='B') k1++;
        for(int i=1;i&lt;=n;i++)
        if(f[i][r]=='B') k2++;
        //cout&lt;&lt;k1&lt;&lt;&quot; &quot;&lt;&lt;k2&lt;&lt;&quot;\n&quot;;
        if(k3==0) puts(&quot;-1&quot;);
        else
        {
            if(f[c][r]=='B') puts(&quot;0&quot;);
            else if(k1||k2) puts(&quot;1&quot;);
            
            else puts(&quot;2&quot;);

            
        }
    }
    
    return 0;
}
</code></pre>
<p>B:舔狗的故事<br>
做法：首先是舔狗先选位置，女神会坐在距离他最远的地方，所以求出每个位置的距离，排个序输出就好了</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
#define LOCAL
using namespace std;
const int N = 550;
using pii = pair&lt;int, int&gt;;
pii que[N];

int t, n, k,m;
vector&lt;int&gt; e;
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        e.clear();
        for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
    
            e.push_back(max(max(i-1+j-1,abs(i-n)+j-1),max(abs(i-n)+abs(j-m),i-1+abs(j-m))));

        }
        sort(e.begin(),e.end());
        for(auto x:e) cout&lt;&lt;x&lt;&lt;&quot; &quot;;
        puts(&quot;&quot;);
    }
    
    return 0;
}
</code></pre>
<p>c:<br>
素数除去2剩下的都是奇数，若想相邻两条边加起来还是素数，那么最终的形式只能是一条链，然后边权23交替就好</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LOCAL
#define x first
#define y second
using namespace std;
int t;
int n;
typedef pair&lt;int,int&gt; pii;
const int N=1e5+10;
int h[N],e[2*N],ne[2*N],idx;
pii q[N];
int c[N];
map&lt;pii,int&gt; mp;
int res;
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int u,int fa)
{
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        mp[{u,j}]=mp[{j,u}]=res;
        res=5-res;
        dfs(j,u);
    }
}
int main()
{
    #if ONLINE_JUDGE
    #else
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    cin&gt;&gt;t;
    while(t--)
    {
        idx=0;
        mp.clear();
        memset(h,-1,sizeof h);
        cin&gt;&gt;n;
        for(int i=1;i&lt;=n;i++) c[i]=0;
        bool fl=true;
        for(int i=1;i&lt;n;i++)
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            add(x,y),add(y,x);
            q[i]={x,y};
            c[x]++,c[y]++;
        }
        int l;
        for(int i=1;i&lt;=n;i++)
        {
            if(c[i]&gt;2) 
            {
                fl=false;
                break;
            }
            if(c[i]==1) l=i;
        }
        //cout&lt;&lt;l&lt;&lt;&quot;\n&quot;;
        res=2;
        if(!fl) puts(&quot;-1&quot;);
        else
        {
            dfs(l,-1);
            for(int i=1;i&lt;n;i++) cout&lt;&lt;mp[q[i]]&lt;&lt;&quot; &quot;;
            puts(&quot;&quot;);
        }
    }


    return 0;
}
</code></pre>
<p>d:<br>
由于gcd(a,b)小于等于ab的最小值，所以我们可以考虑对于一个数x若未出现在序列中，如果存在在序列中的大于x的倍数的gcd是x，那么通过一系列gcd操作就可以得到这个数</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
#define x first
#define y second
using namespace std;
int t;
int n;
typedef pair&lt;int, int&gt; pii;
const int N = 1e6 + 10;

bool st[N];

int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif

    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        int x;
        cin &gt;&gt; x;
        st[x] = true;
    }
    int ans = 0;
    for (int i = 5e5; i; i--)
    {
        if (!st[i])
        {
            int k = 0;
            for (int j = i; j &lt;= 1e6; j += i)
                if (st[j])
                    k = __gcd(k, j);
            if (k == i)
                ans++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;

    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>