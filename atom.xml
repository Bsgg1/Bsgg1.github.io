<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Bsgg1.github.io/</id>
    <title>松松的小窝</title>
    <updated>2022-02-09T11:44:35.530Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Bsgg1.github.io/"/>
    <link rel="self" href="https://Bsgg1.github.io/atom.xml"/>
    <subtitle>代码最终篇，无爱自然神</subtitle>
    <logo>https://Bsgg1.github.io/images/avatar.png</logo>
    <icon>https://Bsgg1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 松松的小窝</rights>
    <entry>
        <title type="html"><![CDATA[土狗daisiki的日常坐牢]]></title>
        <id>https://Bsgg1.github.io/post/tu-gou-daisiki-de-ri-chang-zuo-lao/</id>
        <link href="https://Bsgg1.github.io/post/tu-gou-daisiki-de-ri-chang-zuo-lao/">
        </link>
        <updated>2022-02-07T06:32:56.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://Bsgg1.github.io//post-images/1644215628068.jpg" alt="" loading="lazy"><br>
https://codeforces.com/contest/1508/problem/A<br>
Tag:字符串，思维构造<br>
题意：给三个由0和1构成的字符p_i，长度为2n，构造一个长度为3n的字符串S，让至少两个p是S的子序列<br>
思路：首先可以得出任意p_i的cnt_0或者cnt_1是大于等于n的，考虑为什么是三个p?抽屉原理，一定会有两个p同时满足cnt1或者cnt0大于等于n，这样我们就固定好了n的长度，剩下的长度是2n,直接放就可以</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
string s[3];
int f[3];
int t, n;
string check(int a, int b)
{
	char x;
	string ans;
	if (f[a] &gt;= n)
		x = '1';
	else
		x = '0';
	int l = 0, r = 0;
	for (int i = 1; i &lt;= n; i++)
	{
		while (l &lt; 2 * n &amp;&amp; s[a][l] != x)
			ans += s[a][l++];
		while (r &lt; 2 * n &amp;&amp; s[b][r] != x)
			ans += s[b][r++];
		l++, r++;
		ans += x;
	}
	while (l &lt; 2 * n)
		ans += s[a][l++];
	while (r &lt; 2 * n)
		ans += s[b][r++];
	return ans;
}
void solve()
{
	for (int i = 0; i &lt; 3; i++)
	{
		for (int j = 0; j &lt; 3; j++)
		{
			if (j == i)
				continue;
			if (f[i] &gt; n &amp;&amp; f[j] &lt; n)
				continue;
			if (f[i] &lt; n &amp;&amp; f[j] &gt; n)
				continue;
			string ss = check(i, j);
			if (ss.size() &lt;= n * 3)
			{
				cout &lt;&lt; ss &lt;&lt; &quot;\n&quot;;
				return;
			}
		}
	}
}
int main()
{
	cin &gt;&gt; t;
	while (t--)
	{
		cin &gt;&gt; n;
		f[0] = f[1] = f[2] = 0;
		for (int i = 0; i &lt; 3; i++)
		{
			cin &gt;&gt; s[i];
			for (int j = 0; j &lt; 2 * n; j++)
				if (s[i][j] == '1')
					f[i]++;
		}
		solve();
	}

	return 0;
}
</code></pre>
<p>https://codeforces.com/contest/1381/problem/A2<br>
Tag：思维<br>
字符串a，b，对a进行下列操作至多2n次使得a变成b，操作：选长度为k的前缀，其中0变成1，1变成0，并且翻转<br>
思路：讲a变为全0或者全1至多n次，然后考虑倒着匹配b，至多反转n次</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+10;
vector&lt;int&gt; v;
char s1[N],s2[N];
int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while (t--)
    {
        int n;
        v.clear();
        scanf(&quot;%d%s%s&quot;,&amp;n,s1+1,s2+1);
        if (n == 1)
           {
               if(s1[1]==s2[1]) puts(&quot;0&quot;);
               else puts(&quot;1 1&quot;);
           }
        else
        {
            char r=s1[n];
            for (int i = 2; i &lt;=n; i++)
            {
                if (s1[i] != s1[i - 1])
                {
                    v.push_back(i-1);
                }
            }
            for(int i=n;i&gt;=1;i--)
            {
                if(s2[i]!=r)
                {
                    v.push_back(i);
                    r='1'-r+'0';
                    //cout&lt;&lt;r&lt;&lt;&quot;\n&quot;;
                }
            }
            cout&lt;&lt;v.size()&lt;&lt;&quot; &quot;;
            for(auto x:v) cout&lt;&lt;x&lt;&lt;&quot; &quot;;
            puts(&quot;&quot;);
        }
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串相关(持续更新)]]></title>
        <id>https://Bsgg1.github.io/post/zi-fu-chuan-xiang-guan-chi-xu-geng-xin/</id>
        <link href="https://Bsgg1.github.io/post/zi-fu-chuan-xiang-guan-chi-xu-geng-xin/">
        </link>
        <updated>2022-01-28T10:24:22.000Z</updated>
        <content type="html"><![CDATA[<p>1.字符串的Border,如果字符串S的同长度的前缀与后缀完全相同，则称此前缀为一个border<br>
例如：S=bbabbab,则他的border有b,bbab,字符串本身也可以是border，具体根据题意判断<br>
2.周期与循环节<br>
用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>代表s的长度，下标从1开始<br>
对于p，如果满足p &lt; i <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> 都有s(i)=s(i-p),那么p是s的一个周期<br>
特别：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>也是s的一个周期<br>
循环节：若字符串的周期满足 p<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> ,则p是s的循环节<br>
特别：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>也是s的循环节<br>
结论：<br>
p是s的周期<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⟸</mo></mrow><annotation encoding="application/x-tex">\Longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟸</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>s<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>-p是s的border<br>
传递性S的border的border也是S的border<br>
求S的所有border等价于求S的所有前缀的最大border<br>
KMP<br>
next数组：<br>
next(i)=preffix(i)的非平凡的最大border(非平凡指去掉本身)<br>
next(1)=0<br>
考虑preffix(i)的大于1的border，去掉最后一个就变成了preffix(i-1)的border，所以求next(i)的时候，遍历preffix(i-1)的所有border，即next(i-1),next(next(i-1))....0,验证后一个字符是不是等于s(i)即可</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
const int N = 1000010;
char a[N], b[N];
int nxt[N], n, m;

void kmp_nxt(char *s)
{
    for (int i = 2, j = 0; i &lt;= m; ++i)
    {

        nxt[i] = nxt[i - 1];
        while (nxt[i] &amp;&amp; s[i] != s[nxt[i] + 1])
            nxt[i] = nxt[nxt[i]];
        nxt[i] += (s[i] == s[nxt[i] + 1]);
    }
}

void solve() 
{
    scanf(&quot;%s%s&quot;, a + 1, b + 1);
    n = strlen(a + 1), m = strlen(b + 1);
    kmp_nxt(b);
    for (int i = 1, j = 0; i &lt;= n; ++i)
    {
        while (j &amp;&amp; a[i] != b[j + 1])
            j = nxt[j];
        if (a[i] == b[j + 1])
            ++j;
        if (j == m)
        {
            printf(&quot;%d\n&quot;, i - j + 1);
        }
    }

    for (int i = 1; i &lt;= m; ++i)
        printf(&quot;%d &quot;, nxt[i]);
}

int main()
{
    int _ = 1;
    while (_--)
        solve();
    return 0;
}
</code></pre>
<p>例题：<br>
对于字符串S，求他的最长子串p，满足p是S的前缀，p是S的后缀，同时p至少在S中出现三次<br>
思路：首先p是S的border，可以通过kmp求出，由于p要最长且出现三次，可以确定答案一定在nxt(n)与nxt(nxt(n))之间，因为nxt(nxt(n))在S中至少出现了四次，所以答案就在这两个里边，注意特判掉不存在的情况</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+10;
char s[N];
int nxt[N];
int len;
void kmp()
{
	nxt[1]=0;
	for(int i=2;i&lt;=len;i++)
	{
		nxt[i]=nxt[i-1];
		while(nxt[i]&amp;&amp;s[i]!=s[nxt[i]+1]) nxt[i]=nxt[nxt[i]];
		nxt[i]+=(s[i]==s[nxt[i]+1]);
	}
}
int main()
{
	scanf(&quot;%s&quot;,s+1);
	len=strlen(s+1);
	kmp();
	if(nxt[len]==0) 
	{
		puts(&quot;Just a legend&quot;);
	}
	else
	{
		bool f=false;
		for(int i=1;i&lt;len;i++) if(nxt[i]==nxt[len]) {f=true;break;}
		if(f) for(int i=1;i&lt;=nxt[len];i++) cout&lt;&lt;s[i];
		else{ 
            if(nxt[nxt[len]])
            for(int i=1;i&lt;=nxt[nxt[len]];i++) cout&lt;&lt;s[i];
            else puts(&quot;Just a legend&quot;);
        }

	}

	return 0;
}
</code></pre>
<p>Border的性质：<br>
周期定理：若p,q都是S的周期，那么gcd(p,q)，也是S的周期<br>
一个串的Border数量是O(n)个，但是他们组成了(logN)个等差数列<br>
Border树：<br>
对于一个字符串S，他的border树(nxt树)共有n+1个节点<br>
0是根节点，对于其他节点i的父节点是nxt(i)<br>
性质：<br>
每个前缀的所有border，节点i到根的链<br>
哪些前缀有长度为x的border：x的子树<br>
求两个前缀的公共border等于求LCA</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客寒假集训营第一场补题(现场情况：9题)]]></title>
        <id>https://Bsgg1.github.io/post/niu-ke-han-jia-ji-xun-ying-di-yi-chang-bu-ti-xian-chang-qing-kuang-9-ti/</id>
        <link href="https://Bsgg1.github.io/post/niu-ke-han-jia-ji-xun-ying-di-yi-chang-bu-ti-xian-chang-qing-kuang-9-ti/">
        </link>
        <updated>2022-01-25T07:38:13.000Z</updated>
        <content type="html"><![CDATA[<p>B：在%3意义下一样的数，在同一区间内分数的变化情况是一样的，考虑倍增去维护</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+10;
int n,q;
char s[N];
int st[3][N][21];
void init()
{
    for(int i=0;i&lt;=20;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            if(i==0)
            {
                if(s[j]=='W') st[0][j][i]=st[1][j][i]=st[2][j][i]=1;
                if(s[j]=='L')
                {
                    st[1][j][i]=st[2][j][i]=-1;
                    st[0][j][i]=0;
                }
                if(s[j]=='D')
                st[0][j][i]=st[1][j][i]=st[2][j][i]=0;
            }
            else
            {
                int mid=j+(1&lt;&lt;(i-1));
                if(mid&gt;n)
                {
                    for(int k=0;k&lt;3;k++) 
                    st[k][j][i]=st[k][j][i-1];
                }
                else
                {
                    for(int k=0;k&lt;3;k++)
                    st[k][j][i]=st[k][j][i-1]+st[((k+st[k][j][i-1])%3+3)%3][mid][i-1];
                }
            }
        }
    }
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
    scanf(&quot;%s&quot;,s+1);
    init();
    while(q--)
    {
        int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        int l=a;
        while(l&lt;=b)
        {
            int j=0;
            while(l+(1&lt;&lt;j)-1&lt;=b) j++;
            j--;
            c+=st[c%3][l][j];
            l=l+(1&lt;&lt;j);
        }
        cout&lt;&lt;c&lt;&lt;&quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<p>K:考虑当前位置是i，连续的三个岛是jkl，则dp(i,j,k,l)可以从dp(i-1,x,j,k)转移，再根据题目的要求进行转移</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5 + 10;
int n;
char c[N];
int f[N][4][4][4];
int main()
{
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%s&quot;, c + 1);
    memset(f, -1, sizeof f);
    if (c[n] == 'G')
    {
        f[n][1][1][1] = 3;
        f[n][1][1][2] = 2;
        f[n][1][2][1] = 2;
        f[n][2][1][1] = 2;
        f[n][1][1][3] = 2;
        f[n][1][3][1] = 2;
        f[n][3][1][1] = 2;
        f[n][1][3][3] = 1;
        f[n][3][1][3] = 1;
        f[n][3][3][1] = 1;
    }
    else if (c[n] == 'R')
    {
        f[n][2][2][2] = 0;
        f[n][2][2][3] = 0;
        f[n][2][3][2] = 0;
        f[n][3][2][2] = 0;
        f[n][2][3][3] = 0;
        f[n][3][2][3] = 0;
        f[n][3][3][2] = 0;
        f[n][1][2][2] = 1;
        f[n][2][1][2] = 1;
        f[n][2][2][1] = 1;
    }
    else
    {
        f[n][3][3][3] = 0;
        f[n][3][2][1] = 1;
        f[n][3][1][2] = 1;
        f[n][1][2][3] = 1;
        f[n][1][3][2] = 1;
        f[n][2][1][3] = 1;
        f[n][2][3][1] = 1;
    }
    for (int i = n - 1; i &gt;= 3; i--)
    {
        if (c[i] == 'G')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][1][1][j] != -1)
                    f[i][1][1][1] = max(f[i][1][1][1], f[i + 1][1][1][j] + 1);
                if (f[i + 1][1][3][j] != -1)
                    f[i][1][1][3] = max(f[i][1][1][3], f[i + 1][1][3][j] + 1);
                if (f[i + 1][3][1][j] != -1)
                    f[i][1][3][1] = max(f[i][1][3][1], f[i + 1][3][1][j] + 1);
                if (f[i + 1][1][1][j] != -1)
                    f[i][3][1][1] = max(f[i][3][1][1], f[i + 1][1][1][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][1][1][2] = max(f[i][1][1][2], f[i + 1][1][2][j] + 1);
                if (f[i + 1][2][1][j] != -1)
                    f[i][1][2][1] = max(f[i][1][2][1], f[i + 1][2][1][j] + 1);
                if (f[i + 1][1][1][j] != -1)
                    f[i][2][1][1] = max(f[i][2][1][1], f[i + 1][1][1][j]);
                if (f[i + 1][3][3][j] != -1)
                    f[i][1][3][3] = max(f[i][1][3][3], f[i + 1][3][3][j] + 1);
                if (f[i + 1][1][3][j] != -1)
                    f[i][3][1][3] = max(f[i][3][1][3], f[i + 1][1][3][j]);
                if (f[i + 1][3][1][j] != -1)
                    f[i][3][3][1] = max(f[i][3][3][1], f[i + 1][3][1][j]);
            }
        }
        if (c[i] == 'R')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][2][2][j] != -1)
                    f[i][2][2][2] = max(f[i][2][2][2], f[i + 1][2][2][j] + 0);
                if (f[i + 1][2][3][j] != -1)
                    f[i][2][2][3] = max(f[i][2][2][3], f[i + 1][2][3][j] + 0);
                if (f[i + 1][3][2][j] != -1)
                    f[i][2][3][2] = max(f[i][2][3][2], f[i + 1][3][2][j] + 0);
                if (f[i + 1][2][2][j] != -1)
                    f[i][3][2][2] = max(f[i][3][2][2], f[i + 1][2][2][j] + 0);
                if (f[i + 1][2][1][j] != -1)
                    f[i][2][2][1] = max(f[i][2][2][1], f[i + 1][2][1][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][2][1][2] = max(f[i][2][1][2], f[i + 1][1][2][j]);
                if (f[i + 1][2][2][j] != -1)
                    f[i][1][2][2] = max(f[i][1][2][2], f[i + 1][2][2][j] + 1);
                if (f[i + 1][3][3][j] != -1)
                    f[i][2][3][3] = max(f[i][2][3][3], f[i + 1][3][3][j] + 0);
                if (f[i + 1][2][3][j] != -1)
                    f[i][3][2][3] = max(f[i][3][2][3], f[i + 1][2][3][j] + 0);
                if (f[i + 1][3][2][j] != -1)
                    f[i][3][3][2] = max(f[i][3][3][2], f[i + 1][3][2][j] + 0);
            }
        }
        if (c[i] == 'B')
        {
            for (int j = 1; j &lt;= 3; j++)
            {
                if (f[i + 1][3][3][j] != -1)
                    f[i][3][3][3] = max(f[i][3][3][3], f[i + 1][3][3][j]);
                if (f[i + 1][1][2][j] != -1)
                    f[i][3][1][2] = max(f[i][3][1][2], f[i + 1][1][2][j]);
                if (f[i + 1][2][1][j] != -1)
                    f[i][3][2][1] = max(f[i][3][2][1], f[i + 1][2][1][j]);
                if (f[i + 1][3][2][j] != -1)
                    f[i][1][3][2] = max(f[i][1][3][2], f[i + 1][3][2][j] + 1);
                if (f[i + 1][3][1][j] != -1)
                    f[i][2][3][1] = max(f[i][2][3][1], f[i + 1][3][1][j]);
                if (f[i + 1][1][3][j] != -1)
                    f[i][2][1][3] = max(f[i][2][1][3], f[i + 1][1][3][j]);
                if (f[i + 1][2][3][j] != -1)
                    f[i][1][2][3] = max(f[i][1][2][3], f[i + 1][2][3][j] + 1);
            }
        }
    }
    int ans = -1;
    for (int i = 0; i &lt;= 3; i++)
        for (int j = 0; j &lt;= 3; j++)
            for (int p = 0; p &lt;= 3; p++)
                ans = max(ans, f[3][i][j][p]);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021济南ICPC补]]></title>
        <id>https://Bsgg1.github.io/post/2021-ji-nan-icpc-bu/</id>
        <link href="https://Bsgg1.github.io/post/2021-ji-nan-icpc-bu/">
        </link>
        <updated>2022-01-23T10:37:26.000Z</updated>
        <content type="html"><![CDATA[<p>虽然已经过去很久了，不过这也是自己参加的第一次icpc，一直没有补题，今天突然想起来了，就把该会的写一写吧<br>
D:考虑第一项为x，第i项是x+(i-1)*d，d是公差，然后很容易想到三分d，然后对于不同的d我们求得就是<br>
x+(i-1)*d-ai，我们令数组ti表示ai-(i-1) d，然后就变成了经典的货仓选址问题，x等于ti的中位数就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define in128 __int128
#define ll long long
#define LOCAL
int n;
const int N=2e5+10;
ll a[N];
ll c[N];
void print(in128 x)
{
	if(x&gt;9) print(x/10);
	putchar(x%10+'0');
}
in128 check(ll d)
{
	for(int i=1;i&lt;=n;i++)
	{
		c[i]=a[i]-d*(i-1);
	}
	sort(c+1,c+n+1);
	ll k=c[(n+1)/2];
	in128 res=0;
	for(int i=1;i&lt;=n;i++)
	res+=abs(c[i]-k);
	return res;
}
int main()
{
	#if ONLINE_JUDGE
	#else
	freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
	freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
	#endif
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	{
		cin&gt;&gt;a[i];
	}
	in128 l=-1e13,r=1e13;
	while(l&lt;r)
	{
		ll mid=l+(r-l)/3;
		ll midmid=r-(r-l)/3;
		if(check(mid)&lt;=check(midmid)) r=midmid-1;
		else l=mid+1;
	}
	print(check(l));
	return 0;
}

</code></pre>
<p>C：如果先手拿的是当前剩余的里边的最大的，后手一定拿的也是最大的，所以最大的一定是成对出现的，然后其次就要奇偶，如果价值ci的有偶数个那么就是两人各一半，反之就是先手多1变成偶数的情况，然后我们考虑从小到大取，对于当前取到的价值，如果说他有k个，k是奇数就先手多拿一个然后变成偶数，现在双方各取k/2个，可以发现价值大的是可以穿插在价值小的中间拿的，但是价值最大的一定是成对出现的</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
const int mod=998244353;
map&lt;int,int&gt; mp;
const int N=1e6+10;
int fac[N],infac[N];
int c[N];
int qpw(int a,int b)
{
    int res=1%mod;
    while(b)
    {
        if(b&amp;1) res=res*a%mod;
        a=a*a%mod;
        b&gt;&gt;=1;
    }
    return res;
}
void init()
{
    fac[0]=1;
    for(int i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%mod;
    infac[N-1]=qpw(fac[N-1],mod-2);
    for(int i=N-2;i&gt;=0;i--) infac[i]=infac[i+1]*(i+1)%mod;
}
int cal(int a,int b)
{
    if(a&lt;b) return 0;
    return fac[a]*infac[b]%mod*infac[a-b]%mod;
}
signed main()
{
    int n;
    init();
    cin&gt;&gt;n;
    while(n--)
    {
        int x;cin&gt;&gt;x;
        c[x]++;
    }
    int sum=0,ans=1;
    for(int i=1;i&lt;N;i++)
    {
        if(c[i]){
            int y=c[i];
        ans=ans*fac[y]%mod*cal(sum+(y)/2,(y)/2)%mod;
        sum+=y;
        }
    }
    cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF 767 div2(垃圾场傻逼题)]]></title>
        <id>https://Bsgg1.github.io/post/cf-767-div2la-ji-chang-sha-bi-ti/</id>
        <link href="https://Bsgg1.github.io/post/cf-767-div2la-ji-chang-sha-bi-ti/">
        </link>
        <updated>2022-01-23T07:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>A：排序后按从ram需求从小到大就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t;
const int N=110;
int a[N],b[N];
struct node{
	int a,b;
	bool operator&lt;(const node&amp;m)
	{
		return a&lt;m.a;
	}
}st[N];
int n,k;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		cin&gt;&gt;n&gt;&gt;k;
		for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].a;
		for(int i=1;i&lt;=n;i++) cin&gt;&gt;st[i].b;
		sort(st+1,st+n+1);
		for(int i=1;i&lt;=n;i++)
		{
			if(k&lt;st[i].a) break;
			k+=st[i].b;
		}
		cout&lt;&lt;k&lt;&lt;&quot;\n&quot;;
	}
	return 0;
}
</code></pre>
<p>B:偶数和奇数的gcd一定是1，所以把所有的奇数都变成偶数就可以了，特判只有一个奇数的情况</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int t;
const int N=110;
int a[N],b[N];
struct node{
	int a,b;
	bool operator&lt;(const node&amp;m)
	{
		return a&lt;m.a;
	}
}st[N];
int n,k;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
		int k=b-a+1;
		if(b==a)
		{
		    if(a==1) puts(&quot;NO&quot;);
		    else puts(&quot;YES&quot;);
		}
		else{
		if(a%2==b%2&amp;&amp;a%2==1) k=k/2+1;
		else k=k/2;
		if(k&lt;=c) puts(&quot;YES&quot;);
		else puts(&quot;NO&quot;);
		}
	}
	return 0;
}
</code></pre>
<p>C：每次找到最大的mex，按照题意模拟就可以</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int t;
#define LOCAL
const int N = 2e5 + 10;
int a[N];
int n, k;
int cnt[N];
int f[N];
int res[N];
int ccnt;
int ans[N];
int main()
{
#if ONLINE_JUDGE
#else
	freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
	freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
	scanf(&quot;%d&quot;, &amp;t);
	while (t--)
	{
		ccnt = 0;
		scanf(&quot;%d&quot;, &amp;n);
		for (int i = 0; i &lt;= n; i++)
			res[i] = ans[i] = f[i] = cnt[i] = 0;
		for (int i = 1; i &lt;= n; i++)
		{
			scanf(&quot;%d&quot;, &amp;a[i]);
			res[a[i]]++;
		}
		int l = 0, r = 0;
		for (int i = 1; i &lt;= n; i++)
		{
			f[a[i]]++;
			while (f[l])
				l++;
			if (!res[l])
			{
				ans[++ccnt] = l;
				for (int j = r + 1; j &lt;= i; j++)
					f[a[j]] = 0, res[a[j]]--;
				r = i;
				l = 0;
			}
		}
		cout &lt;&lt; ccnt &lt;&lt; &quot;\n&quot;;
		for (int i = 1; i &lt;= ccnt; i++)
			cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<p>D:如果存在回文串，只需要考虑3+2，2+3，以及reverse的情况就可以了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string,vector&lt;int&gt;&gt; mp;
set&lt;string&gt; se;
int t,n;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		mp.clear();
		se.clear();
		cin&gt;&gt;n;
		for(int i=1;i&lt;=n;i++)
		{
			string s;cin&gt;&gt;s;
			se.insert(s);
			mp[s].push_back(i);
		}
		bool f=false;
		for(auto &amp;[x,y]:mp)
		{
			string s=x;
			//cout&lt;&lt;x&lt;&lt;&quot;\n&quot;;
			if(s.size()==3)
			{
				string s1=&quot;ab&quot;,s2=&quot;ab&quot;;
				s1[0]=s[2],s1[1]=s[1];
				s2[0]=s[1],s2[1]=s[0];
				if(se.count(s1)){
				if(*mp[s1].begin()&lt;y.back()){
				f=true;
				break;
				}
				}
				if(se.count(s2))
				{
				if(*y.begin()&lt;mp[s2].back()){
				f=true;
				break;
				}
				}
			}
			reverse(s.begin(),s.end());
			if(se.count(s))
			{
				f=true;
				break;
			}
		}
		if(f) puts(&quot;YES&quot;);
		else puts(&quot;NO&quot;);
	}
	return 0;
}
</code></pre>
<p>E:一个长为偶数的框，每次选一个点的四个邻点，一定可以通过选几次不重复地全部覆盖掉这个框，画画图就看明白了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1100;
bool st[N][N];
int t,n;
int main()
{
	cin&gt;&gt;t;
	while(t--)
	{
		cin&gt;&gt;n;
		memset(st,false,sizeof st);
		int ans=0;
		for(int i=1;i&lt;=n;i++)
		{
			for(int j=1;j&lt;=n;j++)
			{
				int x;cin&gt;&gt;x;
				if(!st[i-1][j]&amp;&amp;!st[i+1][j]&amp;&amp;!st[i][j-1]&amp;&amp;!st[i][j+1])
				{
					ans^=x;
					st[i-1][j]=st[i+1][j]=st[i][j-1]=st[i][j+1]=true;
				}
			}
		}
		cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
	}


	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hobbits(傻逼计算几何题)]]></title>
        <id>https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/</id>
        <link href="https://Bsgg1.github.io/post/hobbitssha-bi-ji-suan-ji-he-ti/">
        </link>
        <updated>2022-01-21T13:11:24.000Z</updated>
        <content type="html"><![CDATA[<p>做法：倒着扫一遍维护最高点(最高点不一定是高度最高的点，是覆盖面积最大的点)，然后判断于直线的交点即可</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
const double eps = 1e-8;
typedef pair&lt;double, double&gt; pdd;
const int N=2e5+10;
double operator*(pdd a, pdd b)
{
    return a.x * b.y - a.y * b.x;
}
pdd operator-(pdd a,pdd b)
{
    return {a.x-b.x,a.y-b.y};
}
struct line
{
    pdd st, ed;
}li[N];
pdd poi[N];
int n;
double h;
int dcmp(double a, double b)
{
    if (fabs(a - b) &lt;= eps)
        return 0;
    if (a &lt; b)
        return -1;
    return 1;
}
double getdis(pdd a,pdd b)
{
    double dx=a.x-b.x,dy=a.y-b.y;
    return sqrt(dx*dx+dy*dy);
}
double cross(pdd a,pdd b)
{
    return a*b;
}
pdd get_line_intersection(pdd p, pdd v, pdd q, pdd w)
{
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

pdd get_line_intersection(line a, line b)
{
    return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;h;
    for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;poi[i].x,&amp;poi[i].y);
    pdd mx=poi[n],eye={poi[n].x,poi[n].y+h};
    double ans=0;
    for(int i=n-1;i&gt;=1;i--)
    {
        auto p1=mx-eye,p2=poi[i]-eye,p3=poi[i+1]-eye;
        int f1=dcmp(p1*p2,0),f2=dcmp(p1*p3,0);
        //cout&lt;&lt;f1&lt;&lt;&quot; &quot;&lt;&lt;f2&lt;&lt;&quot;\n&quot;;
        if(f1&lt;=0&amp;&amp;f2&lt;=0)
        ans+=getdis(poi[i],poi[i+1]);
        else if(f1&lt;=0&amp;&amp;f2&gt;0)
        {
            pdd pp=get_line_intersection(line{eye,mx},line{poi[i],poi[i+1]});
            ans+=getdis(pp,poi[i]);
        }
        if(f1&lt;=0) mx=poi[i];
    }
    printf(&quot;%.6lf&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[容斥原理]]></title>
        <id>https://Bsgg1.github.io/post/rong-chi-yuan-li/</id>
        <link href="https://Bsgg1.github.io/post/rong-chi-yuan-li/">
        </link>
        <updated>2022-01-17T07:03:05.000Z</updated>
        <content type="html"><![CDATA[<p>容斥原理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> S-A<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span></span></span></span>B<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> =S-A-B+A<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋂</mo></mrow><annotation encoding="application/x-tex">\bigcap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span></span></span></span>B</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cf round766 div2（四题待更）]]></title>
        <id>https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/</id>
        <link href="https://Bsgg1.github.io/post/cf-round766-div2si-ti-dai-geng/">
        </link>
        <updated>2022-01-15T16:44:34.000Z</updated>
        <content type="html"><![CDATA[<p>A：<br>
首先考虑不可能的情况就是全部都是白色，如果有一个黑色就可以操作一行一列所以一定有解<br>
如果r，c是黑ans为0<br>
r，c所在的列或者行有一个黑就是1<br>
否则就是2</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
#define LOCAL
#define int long long
using namespace std;
const int N = 550;
using pii = pair&lt;int, int&gt;;
pii que[N];
char f[N][N];
int t, n, k,m;
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        int r,c;cin&gt;&gt;c&gt;&gt;r;
        for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        cin&gt;&gt;f[i][j];
        int k1=0,k2=0;
        int k3=0;
        for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(f[i][j]=='B') k3++;
        for(int i=1;i&lt;=m;i++)
        if(f[c][i]=='B') k1++;
        for(int i=1;i&lt;=n;i++)
        if(f[i][r]=='B') k2++;
        //cout&lt;&lt;k1&lt;&lt;&quot; &quot;&lt;&lt;k2&lt;&lt;&quot;\n&quot;;
        if(k3==0) puts(&quot;-1&quot;);
        else
        {
            if(f[c][r]=='B') puts(&quot;0&quot;);
            else if(k1||k2) puts(&quot;1&quot;);
            
            else puts(&quot;2&quot;);

            
        }
    }
    
    return 0;
}
</code></pre>
<p>B:舔狗的故事<br>
做法：首先是舔狗先选位置，女神会坐在距离他最远的地方，所以求出每个位置的距离，排个序输出就好了</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define x first
#define y second
#define LOCAL
using namespace std;
const int N = 550;
using pii = pair&lt;int, int&gt;;
pii que[N];

int t, n, k,m;
vector&lt;int&gt; e;
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;n&gt;&gt;m;
        e.clear();
        for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
    
            e.push_back(max(max(i-1+j-1,abs(i-n)+j-1),max(abs(i-n)+abs(j-m),i-1+abs(j-m))));

        }
        sort(e.begin(),e.end());
        for(auto x:e) cout&lt;&lt;x&lt;&lt;&quot; &quot;;
        puts(&quot;&quot;);
    }
    
    return 0;
}
</code></pre>
<p>c:<br>
素数除去2剩下的都是奇数，若想相邻两条边加起来还是素数，那么最终的形式只能是一条链，然后边权23交替就好</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define LOCAL
#define x first
#define y second
using namespace std;
int t;
int n;
typedef pair&lt;int,int&gt; pii;
const int N=1e5+10;
int h[N],e[2*N],ne[2*N],idx;
pii q[N];
int c[N];
map&lt;pii,int&gt; mp;
int res;
void add(int a,int b)
{
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs(int u,int fa)
{
    for(int i=h[u];i!=-1;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        mp[{u,j}]=mp[{j,u}]=res;
        res=5-res;
        dfs(j,u);
    }
}
int main()
{
    #if ONLINE_JUDGE
    #else
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    #endif
    cin&gt;&gt;t;
    while(t--)
    {
        idx=0;
        mp.clear();
        memset(h,-1,sizeof h);
        cin&gt;&gt;n;
        for(int i=1;i&lt;=n;i++) c[i]=0;
        bool fl=true;
        for(int i=1;i&lt;n;i++)
        {
            int x,y;cin&gt;&gt;x&gt;&gt;y;
            add(x,y),add(y,x);
            q[i]={x,y};
            c[x]++,c[y]++;
        }
        int l;
        for(int i=1;i&lt;=n;i++)
        {
            if(c[i]&gt;2) 
            {
                fl=false;
                break;
            }
            if(c[i]==1) l=i;
        }
        //cout&lt;&lt;l&lt;&lt;&quot;\n&quot;;
        res=2;
        if(!fl) puts(&quot;-1&quot;);
        else
        {
            dfs(l,-1);
            for(int i=1;i&lt;n;i++) cout&lt;&lt;mp[q[i]]&lt;&lt;&quot; &quot;;
            puts(&quot;&quot;);
        }
    }


    return 0;
}
</code></pre>
<p>d:<br>
由于gcd(a,b)小于等于ab的最小值，所以我们可以考虑对于一个数x若未出现在序列中，如果存在在序列中的大于x的倍数的gcd是x，那么通过一系列gcd操作就可以得到这个数</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
#define x first
#define y second
using namespace std;
int t;
int n;
typedef pair&lt;int, int&gt; pii;
const int N = 1e6 + 10;

bool st[N];

int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif

    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)
    {
        int x;
        cin &gt;&gt; x;
        st[x] = true;
    }
    int ans = 0;
    for (int i = 5e5; i; i--)
    {
        if (!st[i])
        {
            int k = 0;
            for (int j = i; j &lt;= 1e6; j += i)
                if (st[j])
                    k = __gcd(k, j);
            if (k == i)
                ans++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF round 756 div2（未完待更）]]></title>
        <id>https://Bsgg1.github.io/post/cf-round-756/</id>
        <link href="https://Bsgg1.github.io/post/cf-round-756/">
        </link>
        <updated>2022-01-14T15:44:15.000Z</updated>
        <content type="html"><![CDATA[<p>A:<br>
考虑对于二进制的某一位，如果1的数量大于0的数量那么这一位就需要是1</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
int c1[50], c2[50];
int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;
        for (int i = 0; i &lt; k; i++)
            c1[i] = c2[i] = 0;
        while (n--)
        {
            int x;
            cin &gt;&gt; x;
            for (int i = 0; i &lt; k; i++)
            {
                if (x % 2 == 1)
                    c1[i]++;
                else
                    c2[i]++;
                x /= 2;
            }
        }
    
        int a = 1, res = 0;
        for (int i = 0; i &lt; k; i++)
        {
            if (c1[i] &gt; c2[i])
                res = res + a;
            a = a * 2;
        }
        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre>
<p>B:<br>
很容易想到体中所说的匹配指的是存在两个一样的k，他们前边有a个数，后边有b个数，让a+b+1最大<br>
然后我们发现长度就是n-dis(k1,k2)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
const int N=2e5+10;
vector&lt;int&gt; e[N];
int a[N];
int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        for(int i=1;i&lt;=150000;i++) e[i].clear();
        int n, k;
        cin &gt;&gt; n;
        for(int i=1;i&lt;=n;i++)
        {
            int x;cin&gt;&gt;x;
            e[x].push_back(i);
        }
        int res=-1;

        for(int i=1;i&lt;=150000;i++)
        {
            if(e[i].size()&gt;=2)
            {
                k=0x3f3f3f3f;
                for(int j=1;j&lt;e[i].size();j++)
                {
                    k=min(k,e[i][j]-e[i][j-1]);
                }
                res=max(res,n-k);
            }
        }
        cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;
    }

    return 0;
}
</code></pre>
<p>C：考虑第i个位置是从第j个位置转移来的，n3dp</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 550;
int a[N], d[N], dp[N][N];
int n, l, k;
int main()
{
	cin &gt;&gt; n &gt;&gt; l &gt;&gt; k;
	for (int i = 1; i &lt;= n; i++)
		cin &gt;&gt; a[i];
	a[n + 1] = l;
	for (int i = 1; i &lt;= n; i++)
		cin &gt;&gt; d[i];
	d[n + 1] = 0;
	n++;
	memset(dp, 0x3f, sizeof dp);
	dp[1][0] = 0;
	for (int i = 2; i &lt;= n; i++){
		for (int j = 0; j &lt;= k; j++){
			dp[i][j] = dp[i - 1][j] + (a[i] - a[i - 1]) * d[i - 1];
			for(int s=1;s&lt;i;s++)
			{
				if(j-(i-s-1)&lt;0) continue;
				dp[i][j]=min(dp[i][j],dp[s][j-(i-s-1)]+(a[i]-a[s])*d[s]); 
			}
		}
	}
	int res=0x3f3f3f3f;
	for(int i=0;i&lt;=k;i++) res=min(res,dp[n][i]);
	cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[积性函数，莫比乌斯反演]]></title>
        <id>https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/</id>
        <link href="https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/">
        </link>
        <updated>2022-01-14T10:24:43.000Z</updated>
        <content type="html"><![CDATA[<p>积性函数的定义：如果对于一个函数F : N - R,对于任意互质的a与b都有F(ab)=F(a)f(b),则称F为积性函数<br>
如果F与G都是积性函数，那么H(i)=F(i)G(i) 也是积性函数<br>
如何求解积性函数？<br>
n=p1<sup>q1</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p2<sup>q2</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p3<sup>q3</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> pn<sup>qn</sup><br>
所以F(n)=F(p1<sup>q1</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(p2<sup>q2</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(pn<sup>qn</sup>)</p>
<p>利用欧拉筛求F(1-n)</p>
<pre><code class="language-cpp">f[1]=1;
for(int i=2;i&lt;=n;i++)
{
    if(!st[i]) prime[++cnt]=i;f[i]=cal_f(i,1);
    for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)
    {
        st[i*prime[j]]=true;
        if(i%j==0)
        {
            cnt[i*prime[j]]=cnt[i]+1;
            f[i*prime[j]]=f[i]/cal_f(p[j],cnt[i])*cal_f(p[j],cnt[i*f[j]]);
            break;
        }
        cnt[i*f[j]]=1;
        f[i*prime[j]]=f[i]*cal_f(f[j],1);
    }
}

</code></pre>
<p>练习<br>
1.简单应用：<br>
求 1<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 2<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> n<sup>n</sup><br>
定义函数F，F(i)=i<sup>n</sup>,所以F是一个积性函数，可以预处理出来1-n的F值，然后进行求解</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
#define int long long
const int N = 1e6 + 10;
const int mod = 1e9 + 7;
int f[N * 13], prime[N];
bool st[N * 13];
int c[N];
int cnt;
int n;
int qpw(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}
void init()
{
    for (int i = 2; i &lt;= n; i++)
    {
        if (!st[i])
            prime[++cnt] = i, f[i] = qpw(i, n);
        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)
        {
            st[prime[j] * i] = true;
            f[i * prime[j]] = f[i] * f[prime[j]] % mod;
            if (i % prime[j] == 0)
                break;
        }
    }
}

signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    f[1] = 1;
    cin &gt;&gt; n;
    init();
    int res = 0;
    for (int i = 1; i &lt;= n; i++)
        res = (res ^ f[i]);
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<p>结论：F是一个积性函数的话，G=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>nF(d)也是积性函数<br>
题目：cf 757-E<br>
题意：定义函数F0(n)=u*v==n&amp;&amp;gcd(u,v)==1的个数<br>
很显然我们可以发现F0(n)=2<sup>k</sup>,k是n分解后的项数，所以F0是一个积性函数<br>
Fr(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>n Fr-1(d)<br>
根据推论所以Fr也是一个积性函数<br>
对于Fr(n)=Fr(p1<sup>q1</sup>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span>Fr(p2<sup>q2</sup>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> Fr(pn<sup>qn</sup>)<br>
然后可以发现对于形如Fr(p1<sup>q1</sup>)的求解是通过递归求得的，并且与p1无关，q最大是20，所以可以先预处理，然后进行求解<br>
这个题在处理素数时可以只处理1000以内的素数，一个数最多有一个质因子是大于根号的<br>
代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define LOCAL
#define ll long long
const int N = 1e6 + 1, M = 21;
const int mod = 1e9 + 7;
int f[N][M];
int t;
int n, m;
int res, k;
int prime[N];
bool st[N];
int cnt;
void init()
{
    for (int i = 2; i &lt;= 1000; i++)
    {
        if (!st[i])
            prime[++cnt] = i;
        for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++)
        {
            st[i * prime[j]] = true;
            if (i % prime[j] == 0)
                break;
        }
    }
}
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    init();
    f[0][0] = 1;
    for (int i = 1; i &lt; M; i++)
        f[0][i] = 2;
    for (int i = 1; i &lt; N; i++)
    {
        for (int j = 0; j &lt; M; j++)
            if (j == 0)
                f[i][j] = 1;
            else
                f[i][j] = (f[i][j - 1] + f[i - 1][j]) % mod;
    }
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        res = 1;
        for (int i = 1; i &lt;= cnt; i++)
        {
            k = 0;
            if (m &lt; prime[i])
                break;
            while (m % prime[i] == 0)
            {
                m /= prime[i];
                k++;
            }
            res = 1ll * res * f[n][k] % mod;
        }
        if (m &gt; 1)
            res = 1ll * res * f[n][1] % mod;
        printf(&quot;%d\n&quot;, res);
    }

    return 0;
}
</code></pre>
<p>莫比乌斯反演：<br>
莫比乌斯函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>(n)=(-1)<sup>k</sup> 如果n=p1 p2 p3 .. pk,反之就是0，n=1的时候为1<br>
f与g是两个函数<br>
f(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>n g(d),则 g(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>(n/d)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>f(d)<br>
f与g是两个函数,存在N，当n大于N是f(n)=g(n)=0<br>
f(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>m g(m),则 g(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>n<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>m<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>(m/n)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>f(m)<br>
狄利克雷卷积 :符合交换律与结合律<br>
设f n-&gt;R g n-&gt;R是两个函数，则他们的狄利克雷卷积为(f<em>g)(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>n f(d)g(n/d)<br>
如果f和g都是积性函数，那么他们的狄利克雷卷积也是积性函数<br>
f=g与1的狄利克雷卷积 -&gt; g=f与u的狄利克雷卷积<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span> = u</em>1     <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ε</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>nu(d)<br>
d=1<em>1<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>=id * 1<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span> =u</em>id<br>
应用：杜教筛<br>
M(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>(1-n) u(i)  (n范围1e11)<br>
M(n)=1-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>(2-n)M(n/i(下取整))</p>
<pre><code class="language-cpp">inline ll GetSumu(int n) {
  if(n &lt;= N) return sumu[n]; // sumu是提前筛好的前缀和
  if(Smu[n]) return Smu[n]; // 记忆化
  ll ret = 1ll; // 单位元的前缀和就是 1
  for(int l = 2, r; l &lt;= n; l = r + 1) {
    r = n / (n / l); ret -= (r - l + 1) * GetSumu(n / l);
    // (r - l + 1) 就是 I 在 [l, r] 的和
  } return Smu[n] = ret; // 记忆化
}
</code></pre>
<p>函数d(a*b)表示a×b的约数个数<br>
那么d=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> x<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span> y<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>b gcd(x,y)==1</p>
]]></content>
    </entry>
</feed>