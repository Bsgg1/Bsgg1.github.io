<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Bsgg1.github.io/</id>
    <title>松松的小窝</title>
    <updated>2022-01-15T16:44:31.760Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Bsgg1.github.io/"/>
    <link rel="self" href="https://Bsgg1.github.io/atom.xml"/>
    <subtitle>代码最终篇，无爱自然神</subtitle>
    <logo>https://Bsgg1.github.io/images/avatar.png</logo>
    <icon>https://Bsgg1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 松松的小窝</rights>
    <entry>
        <title type="html"><![CDATA[CF round 756 div2（未完待更）]]></title>
        <id>https://Bsgg1.github.io/post/cf-round-756/</id>
        <link href="https://Bsgg1.github.io/post/cf-round-756/">
        </link>
        <updated>2022-01-14T15:44:15.000Z</updated>
        <content type="html"><![CDATA[<p>A:<br>
考虑对于二进制的某一位，如果1的数量大于0的数量那么这一位就需要是1</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
int c1[50], c2[50];
int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;
        for (int i = 0; i &lt; k; i++)
            c1[i] = c2[i] = 0;
        while (n--)
        {
            int x;
            cin &gt;&gt; x;
            for (int i = 0; i &lt; k; i++)
            {
                if (x % 2 == 1)
                    c1[i]++;
                else
                    c2[i]++;
                x /= 2;
            }
        }
    
        int a = 1, res = 0;
        for (int i = 0; i &lt; k; i++)
        {
            if (c1[i] &gt; c2[i])
                res = res + a;
            a = a * 2;
        }
        cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    }

    return 0;
}
</code></pre>
<p>B:<br>
很容易想到体中所说的匹配指的是存在两个一样的k，他们前边有a个数，后边有b个数，让a+b+1最大<br>
然后我们发现长度就是n-dis(k1,k2)</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
const int N=2e5+10;
vector&lt;int&gt; e[N];
int a[N];
int main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    int t;
    cin &gt;&gt; t;
    while (t--)
    {
        for(int i=1;i&lt;=150000;i++) e[i].clear();
        int n, k;
        cin &gt;&gt; n;
        for(int i=1;i&lt;=n;i++)
        {
            int x;cin&gt;&gt;x;
            e[x].push_back(i);
        }
        int res=-1;

        for(int i=1;i&lt;=150000;i++)
        {
            if(e[i].size()&gt;=2)
            {
                k=0x3f3f3f3f;
                for(int j=1;j&lt;e[i].size();j++)
                {
                    k=min(k,e[i][j]-e[i][j-1]);
                }
                res=max(res,n-k);
            }
        }
        cout&lt;&lt;res&lt;&lt;&quot;\n&quot;;
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[积性函数，莫比乌斯反演(未完待更)]]></title>
        <id>https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/</id>
        <link href="https://Bsgg1.github.io/post/ji-xing-han-shu-mo-bi-wu-si-fan-yan/">
        </link>
        <updated>2022-01-14T10:24:43.000Z</updated>
        <content type="html"><![CDATA[<p>积性函数的定义：如果对于一个函数F : N - R,对于任意互质的a与b都有F(ab)=F(a)f(b),则称F为积性函数<br>
如果F与G都是积性函数，那么H(i)=F(i)G(i) 也是积性函数<br>
如何求解积性函数？<br>
n=p1<sup>q1</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p2<sup>q2</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> p3<sup>q3</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> pn<sup>qn</sup><br>
所以F(n)=F(p1<sup>q1</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(p2<sup>q2</sup>) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> F(pn<sup>qn</sup>)</p>
<p>利用欧拉筛求F(1-n)</p>
<pre><code class="language-cpp">f[1]=1;
for(int i=2;i&lt;=n;i++)
{
    if(!st[i]) prime[++cnt]=i;f[i]=cal_f(i,1);
    for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)
    {
        st[i*prime[j]]=true;
        if(i%j==0)
        {
            cnt[i*prime[j]]=cnt[i]+1;
            f[i*prime[j]]=f[i]/cal_f(p[j],cnt[i])*cal_f(p[j],cnt[i*f[j]]);
            break;
        }
        cnt[i*f[j]]=1;
        f[i*prime[j]]=f[i]*cal_f(f[j],1);
    }
}

</code></pre>
<p>练习<br>
1.简单应用：<br>
求 1<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> 2<sup>n</sup> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> n<sup>n</sup><br>
定义函数F，F(i)=i<sup>n</sup>,所以F是一个积性函数，可以预处理出来1-n的F值，然后进行求解</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define LOCAL
using namespace std;
#define int long long
const int N = 1e6 + 10;
const int mod = 1e9 + 7;
int f[N * 13], prime[N];
bool st[N * 13];
int c[N];
int cnt;
int n;
int qpw(int a, int b)
{
    int res = 1;
    while (b)
    {
        if (b &amp; 1)
            res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}
void init()
{
    for (int i = 2; i &lt;= n; i++)
    {
        if (!st[i])
            prime[++cnt] = i, f[i] = qpw(i, n);
        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)
        {
            st[prime[j] * i] = true;
            f[i * prime[j]] = f[i] * f[prime[j]] % mod;
            if (i % prime[j] == 0)
                break;
        }
    }
}

signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    f[1] = 1;
    cin &gt;&gt; n;
    init();
    int res = 0;
    for (int i = 1; i &lt;= n; i++)
        res = (res ^ f[i]);
    cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<p>结论：F是一个积性函数的话，G=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>nF(d)也是积性函数<br>
题目：cf 757-E<br>
题意：定义函数F0(n)=u*v==n&amp;&amp;gcd(u,v)==1的个数<br>
很显然我们可以发现F0(n)=2<sup>k</sup>,k是n分解后的项数，所以F0是一个积性函数<br>
Fr(n)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>d<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span>n Fr-1(d)<br>
根据推论所以Fr也是一个积性函数<br>
对于Fr(n)=Fr(p1<sup>q1</sup>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⨁</mo></mrow><annotation encoding="application/x-tex">\bigoplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨁</span></span></span></span>Fr(p2<sup>q2</sup>)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span> Fr(pn<sup>qn</sup>)<br>
然后可以发现对于形如Fr(p1<sup>q1</sup>)的求解是通过递归求得的，并且与p1无关，q最大是20，所以可以先预处理，然后进行求解<br>
这个题在处理素数时可以只处理1000以内的素数，一个数最多有一个质因子是大于根号的<br>
代码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
#define LOCAL
#define ll long long
const int N = 1e6 + 1, M = 21;
const int mod = 1e9 + 7;
int f[N][M];
int t;
int n, m;
int res, k;
int prime[N];
bool st[N];
int cnt;
void init()
{
    for (int i = 2; i &lt;= 1000; i++)
    {
        if (!st[i])
            prime[++cnt] = i;
        for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; N; j++)
        {
            st[i * prime[j]] = true;
            if (i % prime[j] == 0)
                break;
        }
    }
}
signed main()
{
#if ONLINE_JUDGE
#else
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
#endif
    init();
    f[0][0] = 1;
    for (int i = 1; i &lt; M; i++)
        f[0][i] = 2;
    for (int i = 1; i &lt; N; i++)
    {
        for (int j = 0; j &lt; M; j++)
            if (j == 0)
                f[i][j] = 1;
            else
                f[i][j] = (f[i][j - 1] + f[i - 1][j]) % mod;
    }
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        res = 1;
        for (int i = 1; i &lt;= cnt; i++)
        {
            k = 0;
            if (m &lt; prime[i])
                break;
            while (m % prime[i] == 0)
            {
                m /= prime[i];
                k++;
            }
            res = 1ll * res * f[n][k] % mod;
        }
        if (m &gt; 1)
            res = 1ll * res * f[n][1] % mod;
        printf(&quot;%d\n&quot;, res);
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>